/* tslint:disable */
/* eslint-disable */
/**
 * MyCheckPoint
 * API para la aplicación MyCheckPoint
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * DTO utilizado para confirmar la solicitud de eliminación de cuenta. Requiere la contraseña actual del usuario.
 * @export
 * @interface AccountDeleteDTO
 */
export interface AccountDeleteDTO {
    /**
     * La contraseña actual del usuario. Es necesaria para verificar la identidad antes de programar la eliminación de la cuenta.
     * @type {string}
     * @memberof AccountDeleteDTO
     */
    'contraseña_actual': string;
}
/**
 * DTO para añadir un juego existente de la biblioteca del usuario a una lista de juegos personalizada.
 * @export
 * @interface AddGameToCustomListRequestDTO
 */
export interface AddGameToCustomListRequestDTO {
    /**
     * ID interno de la entrada \'UserGame\' (juego en la biblioteca del usuario) que se desea añadir a la lista. Es obligatorio.
     * @type {number}
     * @memberof AddGameToCustomListRequestDTO
     */
    'user_game_id': number;
}
/**
 * DTO para una obra de arte (artwork) de un juego.
 * @export
 * @interface ArtworkDto
 */
export interface ArtworkDto {
    /**
     * URL de la imagen de la obra de arte.
     * @type {string}
     * @memberof ArtworkDto
     */
    'url'?: string;
    /**
     * ID de la obra de arte desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof ArtworkDto
     */
    'id'?: number;
}
/**
 * DTO con información básica de una compañía (desarrolladora, editora).
 * @export
 * @interface CompanyInfoDto
 */
export interface CompanyInfoDto {
    /**
     * Nombre de la compañía.
     * @type {string}
     * @memberof CompanyInfoDto
     */
    'name'?: string;
    /**
     * ID de la compañía desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof CompanyInfoDto
     */
    'id'?: number;
}
/**
 * DTO para la información de la carátula de un juego.
 * @export
 * @interface CoverDto
 */
export interface CoverDto {
    /**
     * URL de la imagen de la carátula.
     * @type {string}
     * @memberof CoverDto
     */
    'url'?: string;
    /**
     * ID de la carátula desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof CoverDto
     */
    'id'?: number;
}
/**
 * DTO con información resumida de un DLC, expansión o juego relacionado.
 * @export
 * @interface DlcInfoDto
 */
export interface DlcInfoDto {
    /**
     * 
     * @type {CoverDto}
     * @memberof DlcInfoDto
     */
    'cover'?: CoverDto;
    /**
     * Nombre del DLC/expansión/juego relacionado.
     * @type {string}
     * @memberof DlcInfoDto
     */
    'name'?: string;
    /**
     * ID del DLC/expansión/juego relacionado desde IGDB.
     * @type {number}
     * @memberof DlcInfoDto
     */
    'id'?: number;
    /**
     * Calificación total del DLC/expansión/juego relacionado.
     * @type {number}
     * @memberof DlcInfoDto
     */
    'total_rating'?: number | null;
    /**
     * Tipo de juego (ej. DLC, EXPANSION).
     * @type {string}
     * @memberof DlcInfoDto
     */
    'game_type'?: DlcInfoDtoGameTypeEnum;
    /**
     * Slug del DLC/expansión/juego relacionado.
     * @type {string}
     * @memberof DlcInfoDto
     */
    'slug'?: string;
}

export const DlcInfoDtoGameTypeEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15'
} as const;

export type DlcInfoDtoGameTypeEnum = typeof DlcInfoDtoGameTypeEnum[keyof typeof DlcInfoDtoGameTypeEnum];

/**
 * Respuesta específica para errores de recursos duplicados (HTTP 409).
 * @export
 * @interface DuplicatedResourceResponse
 */
export interface DuplicatedResourceResponse {
    /**
     * Mensaje de error indicando que el recurso ya existe.
     * @type {string}
     * @memberof DuplicatedResourceResponse
     */
    'message'?: string;
}
/**
 * Respuesta de error genérica para errores 4xx y 5xx.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Mensaje detallado del error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'error'?: string;
}
/**
 * DTO para la solicitud de restablecimiento de contraseña. Requiere el correo electrónico asociado a la cuenta.
 * @export
 * @interface ForgotPasswordDTO
 */
export interface ForgotPasswordDTO {
    /**
     * Correo electrónico del usuario que solicita el restablecimiento de contraseña. Debe ser un formato de email válido.
     * @type {string}
     * @memberof ForgotPasswordDTO
     */
    'email': string;
}
/**
 * DTO para una franquicia de videojuegos.
 * @export
 * @interface FranchiseDto
 */
export interface FranchiseDto {
    /**
     * Nombre de la franquicia.
     * @type {string}
     * @memberof FranchiseDto
     */
    'name'?: string;
    /**
     * ID de la franquicia desde IGDB.
     * @type {number}
     * @memberof FranchiseDto
     */
    'id'?: number;
}
/**
 * DTO que representa el estado de una amistad o solicitud de amistad.
 * @export
 * @interface FriendshipResponseDTO
 */
export interface FriendshipResponseDTO {
    /**
     * ID interno de la relación de amistad/solicitud.
     * @type {number}
     * @memberof FriendshipResponseDTO
     */
    'friendship_id'?: number;
    /**
     * ID público del otro usuario en la relación (amigo o solicitante/receptor).
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'user_public_id'?: string;
    /**
     * Nombre de usuario del otro usuario en la relación.
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'username'?: string;
    /**
     * URL de la foto de perfil del otro usuario. Puede ser nulo.
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'profile_picture_url'?: string | null;
    /**
     * Estado actual de la amistad o solicitud.
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'status'?: FriendshipResponseDTOStatusEnum;
    /**
     * Indica si el usuario autenticado fue quien inició originalmente la solicitud de amistad. True si el usuario actual es el \'requester\', False si es el \'receiver\'.
     * @type {boolean}
     * @memberof FriendshipResponseDTO
     */
    'is_initiated_by_current_user'?: boolean;
    /**
     * Fecha y hora de creación de la solicitud o de cuando se estableció la amistad.
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'created_at'?: string;
    /**
     * Fecha y hora de la última actualización del estado (ej. aceptación).
     * @type {string}
     * @memberof FriendshipResponseDTO
     */
    'updated_at'?: string;
}

export const FriendshipResponseDTOStatusEnum = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Declined: 'DECLINED',
    Blocked: 'BLOCKED',
    Pending2: 'PENDING',
    Accepted2: 'ACCEPTED',
    Declined2: 'DECLINED',
    Blocked2: 'BLOCKED'
} as const;

export type FriendshipResponseDTOStatusEnum = typeof FriendshipResponseDTOStatusEnum[keyof typeof FriendshipResponseDTOStatusEnum];

/**
 * DTO que contiene los detalles completos de un juego, incluyendo información general, datos específicos del usuario (si está autenticado y el juego está en su biblioteca), y comentarios públicos.
 * @export
 * @interface GameDetailDTO
 */
export interface GameDetailDTO {
    /**
     * 
     * @type {GameDto}
     * @memberof GameDetailDTO
     */
    'game_info'?: GameDto;
    /**
     * 
     * @type {UserGameResponseDTO}
     * @memberof GameDetailDTO
     */
    'user_game_data'?: UserGameResponseDTO | null;
    /**
     * Lista de comentarios públicos realizados por otros usuarios sobre este juego. Puede estar vacía si no hay comentarios o si el juego no existe en la base de datos local para asociar comentarios.
     * @type {Array<PublicGameCommentDTO>}
     * @memberof GameDetailDTO
     */
    'public_comments'?: Array<PublicGameCommentDTO> | null;
}
/**
 * DTO completo para un videojuego, incluyendo todos sus detalles y relaciones.
 * @export
 * @interface GameDto
 */
export interface GameDto {
    /**
     * 
     * @type {CoverDto}
     * @memberof GameDto
     */
    'cover'?: CoverDto;
    /**
     * Géneros a los que pertenece el juego (ej. RPG, Acción).
     * @type {Array<GenreDto>}
     * @memberof GameDto
     */
    'genres'?: Array<GenreDto> | null;
    /**
     * Nombre completo del juego.
     * @type {string}
     * @memberof GameDto
     */
    'name'?: string;
    /**
     * Identificador URL amigable del juego.
     * @type {string}
     * @memberof GameDto
     */
    'slug'?: string | null;
    /**
     * Resumen o sinopsis del juego.
     * @type {string}
     * @memberof GameDto
     */
    'summary'?: string | null;
    /**
     * Argumento o historia principal del juego.
     * @type {string}
     * @memberof GameDto
     */
    'storyline'?: string | null;
    /**
     * ID único del juego en IGDB.
     * @type {number}
     * @memberof GameDto
     */
    'id'?: number;
    /**
     * Modos de juego disponibles (ej. Un jugador, Multijugador).
     * @type {Array<GameModeDto>}
     * @memberof GameDto
     */
    'game_modes'?: Array<GameModeDto> | null;
    /**
     * Información de los artes del juego.
     * @type {Array<ArtworkDto>}
     * @memberof GameDto
     */
    'artworks'?: Array<ArtworkDto> | null;
    /**
     * Fecha del primer lanzamiento del juego (timestamp Unix en segundos).
     * @type {number}
     * @memberof GameDto
     */
    'first_release_date'?: number | null;
    /**
     * Estado de lanzamiento del juego.
     * @type {string}
     * @memberof GameDto
     */
    'first_release_status'?: GameDtoFirstReleaseStatusEnum | null;
    /**
     * Franquicias a las que pertenece el juego.
     * @type {Array<FranchiseDto>}
     * @memberof GameDto
     */
    'franchises'?: Array<FranchiseDto> | null;
    /**
     * Motores de juego utilizados.
     * @type {Array<GameEngineDto>}
     * @memberof GameDto
     */
    'game_engines'?: Array<GameEngineDto> | null;
    /**
     * Palabras clave asociadas al juego.
     * @type {Array<KeywordDto>}
     * @memberof GameDto
     */
    'keywords'?: Array<KeywordDto> | null;
    /**
     * Plataformas en las que el juego está disponible.
     * @type {Array<PlatformDto>}
     * @memberof GameDto
     */
    'platforms'?: Array<PlatformDto> | null;
    /**
     * Capturas de pantalla del juego.
     * @type {Array<ScreenshotDto>}
     * @memberof GameDto
     */
    'screenshots'?: Array<ScreenshotDto> | null;
    /**
     * Sitios web relacionados con el juego.
     * @type {Array<WebsiteDto>}
     * @memberof GameDto
     */
    'websites'?: Array<WebsiteDto> | null;
    /**
     * Vídeos relacionados con el juego.
     * @type {Array<VideoDto>}
     * @memberof GameDto
     */
    'videos'?: Array<VideoDto> | null;
    /**
     * Calificación total del juego (promedio de usuarios/críticos).
     * @type {number}
     * @memberof GameDto
     */
    'total_rating'?: number | null;
    /**
     * Número total de calificaciones recibidas.
     * @type {number}
     * @memberof GameDto
     */
    'total_rating_count'?: number | null;
    /**
     * Temas principales del juego (ej. Fantasía, Ciencia Ficción).
     * @type {Array<ThemeDto>}
     * @memberof GameDto
     */
    'themes'?: Array<ThemeDto> | null;
    /**
     * Tipo de juego (ej. JUEGO_PRINCIPAL, DLC, EXPANSION).
     * @type {string}
     * @memberof GameDto
     */
    'game_type'?: GameDtoGameTypeEnum;
    /**
     * 
     * @type {DlcInfoDto}
     * @memberof GameDto
     */
    'parent_game'?: DlcInfoDto | null;
    /**
     * Lista de DLCs para este juego.
     * @type {Array<DlcInfoDto>}
     * @memberof GameDto
     */
    'dlcs'?: Array<DlcInfoDto> | null;
    /**
     * Lista de expansiones para este juego.
     * @type {Array<DlcInfoDto>}
     * @memberof GameDto
     */
    'expansions'?: Array<DlcInfoDto> | null;
    /**
     * Lista de paquetes/bundles que incluyen este juego o de los que este juego forma parte.
     * @type {Array<DlcInfoDto>}
     * @memberof GameDto
     */
    'bundles'?: Array<DlcInfoDto> | null;
    /**
     * 
     * @type {DlcInfoDto}
     * @memberof GameDto
     */
    'version_parent'?: DlcInfoDto | null;
    /**
     * Lista de remakes de este juego.
     * @type {Array<DlcInfoDto>}
     * @memberof GameDto
     */
    'remakes'?: Array<DlcInfoDto> | null;
    /**
     * Lista de remasters de este juego.
     * @type {Array<DlcInfoDto>}
     * @memberof GameDto
     */
    'remasters'?: Array<DlcInfoDto> | null;
    /**
     * Lista de juegos similares a este.
     * @type {Array<SimilarGameInfoDto>}
     * @memberof GameDto
     */
    'similar_games'?: Array<SimilarGameInfoDto> | null;
    /**
     * Compañías involucradas en el desarrollo/publicación del juego.
     * @type {Array<InvolvedCompanyDto>}
     * @memberof GameDto
     */
    'involved_companies'?: Array<InvolvedCompanyDto> | null;
    /**
     * 
     * @type {GameStatusDto}
     * @memberof GameDto
     */
    'game_status'?: GameStatusDto | null;
}

export const GameDtoFirstReleaseStatusEnum = {
    _0: '0',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _1: '-1'
} as const;

export type GameDtoFirstReleaseStatusEnum = typeof GameDtoFirstReleaseStatusEnum[keyof typeof GameDtoFirstReleaseStatusEnum];
export const GameDtoGameTypeEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15'
} as const;

export type GameDtoGameTypeEnum = typeof GameDtoGameTypeEnum[keyof typeof GameDtoGameTypeEnum];

/**
 * DTO para un motor de videojuego (Game Engine).
 * @export
 * @interface GameEngineDto
 */
export interface GameEngineDto {
    /**
     * Nombre del motor de juego.
     * @type {string}
     * @memberof GameEngineDto
     */
    'name'?: string;
    /**
     * ID del motor de juego desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof GameEngineDto
     */
    'id'?: number;
}
/**
 * DTO para crear o actualizar una lista de juegos personalizada.
 * @export
 * @interface GameListRequestDTO
 */
export interface GameListRequestDTO {
    /**
     * Nombre de la lista de juegos. Debe tener entre 1 y 150 caracteres.
     * @type {string}
     * @memberof GameListRequestDTO
     */
    'name': string;
    /**
     * Descripción opcional para la lista de juegos. Máximo 1000 caracteres.
     * @type {string}
     * @memberof GameListRequestDTO
     */
    'description'?: string | null;
    /**
     * Indica si la lista de juegos es pública (true) o privada (false).
     * @type {boolean}
     * @memberof GameListRequestDTO
     */
    'is_public': boolean;
}
/**
 * DTO que representa una lista de juegos personalizada, incluyendo sus detalles y los juegos que contiene.
 * @export
 * @interface GameListResponseDTO
 */
export interface GameListResponseDTO {
    /**
     * ID público único de la lista de juegos.
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'public_id'?: string;
    /**
     * Nombre de la lista de juegos.
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'name'?: string;
    /**
     * Descripción de la lista de juegos.
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'description'?: string | null;
    /**
     * Indica si la lista de juegos es pública (true) o privada (false).
     * @type {boolean}
     * @memberof GameListResponseDTO
     */
    'is_public'?: boolean;
    /**
     * Nombre de usuario del propietario de la lista.
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'owner_username'?: string;
    /**
     * Lista de juegos (entradas de la biblioteca del usuario) incluidos en esta lista. Puede estar vacía.
     * @type {Array<UserGameResponseDTO>}
     * @memberof GameListResponseDTO
     */
    'games_in_list'?: Array<UserGameResponseDTO> | null;
    /**
     * Número total de juegos en la lista.
     * @type {number}
     * @memberof GameListResponseDTO
     */
    'game_count'?: number;
    /**
     * Fecha y hora de creación de la lista (formato ISO 8601).
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'created_at'?: string;
    /**
     * Fecha y hora de la última actualización de la lista (formato ISO 8601).
     * @type {string}
     * @memberof GameListResponseDTO
     */
    'updated_at'?: string;
}
/**
 * DTO para un modo de juego.
 * @export
 * @interface GameModeDto
 */
export interface GameModeDto {
    /**
     * Nombre del modo de juego.
     * @type {string}
     * @memberof GameModeDto
     */
    'name'?: string;
    /**
     * ID del modo de juego desde IGDB.
     * @type {number}
     * @memberof GameModeDto
     */
    'id'?: number;
}
/**
 * DTO para el estado de lanzamiento de un juego (ID numérico de IGDB).
 * @export
 * @interface GameStatusDto
 */
export interface GameStatusDto {
    /**
     * ID numérico del estado del juego según IGDB.
     * @type {number}
     * @memberof GameStatusDto
     */
    'id'?: number;
}
/**
 * DTO para un género de videojuego.
 * @export
 * @interface GenreDto
 */
export interface GenreDto {
    /**
     * Nombre del género.
     * @type {string}
     * @memberof GenreDto
     */
    'name'?: string;
    /**
     * ID del género desde IGDB.
     * @type {number}
     * @memberof GenreDto
     */
    'id'?: number;
}
/**
 * DTO para la relación de una compañía con un juego y su rol.
 * @export
 * @interface InvolvedCompanyDto
 */
export interface InvolvedCompanyDto {
    /**
     * 
     * @type {CompanyInfoDto}
     * @memberof InvolvedCompanyDto
     */
    'company'?: CompanyInfoDto;
    /**
     * True si la compañía es desarrolladora.
     * @type {boolean}
     * @memberof InvolvedCompanyDto
     */
    'developer'?: boolean;
    /**
     * True si la compañía realizó la portabilidad del juego.
     * @type {boolean}
     * @memberof InvolvedCompanyDto
     */
    'porting'?: boolean;
    /**
     * True si la compañía es editora.
     * @type {boolean}
     * @memberof InvolvedCompanyDto
     */
    'publisher'?: boolean;
    /**
     * True si la compañía dio soporte al desarrollo.
     * @type {boolean}
     * @memberof InvolvedCompanyDto
     */
    'supporting'?: boolean;
    /**
     * ID de la relación de involucramiento desde IGDB.
     * @type {number}
     * @memberof InvolvedCompanyDto
     */
    'id'?: number;
}
/**
 * DTO para la respuesta de inicio de sesión exitoso. Contiene el token de acceso JWT.
 * @export
 * @interface JwtResponseDTO
 */
export interface JwtResponseDTO {
    /**
     * Token de acceso JWT generado para el usuario autenticado.
     * @type {string}
     * @memberof JwtResponseDTO
     */
    'token_acceso'?: string;
    /**
     * Tipo de token, generalmente \'Bearer\'.
     * @type {string}
     * @memberof JwtResponseDTO
     */
    'tipo_token'?: string;
}
/**
 * DTO para una palabra clave asociada a un juego.
 * @export
 * @interface KeywordDto
 */
export interface KeywordDto {
    /**
     * Nombre de la palabra clave.
     * @type {string}
     * @memberof KeywordDto
     */
    'name'?: string;
    /**
     * ID de la palabra clave desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof KeywordDto
     */
    'id'?: number;
}
/**
 * DTO para la solicitud de inicio de sesión. Requiere un identificador (email o nombre de usuario) y una contraseña.
 * @export
 * @interface LoginRequestDTO
 */
export interface LoginRequestDTO {
    /**
     * Identificador del usuario, puede ser su email o su nombre de usuario.
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'identificador': string;
    /**
     * Contraseña del usuario.
     * @type {string}
     * @memberof LoginRequestDTO
     */
    'contraseña': string;
}
/**
 * DTO para solicitar un cambio de contraseña. Requiere la contraseña actual del usuario y la nueva contraseña deseada.
 * @export
 * @interface PasswordChangeDTO
 */
export interface PasswordChangeDTO {
    /**
     * La contraseña actual del usuario para verificación.
     * @type {string}
     * @memberof PasswordChangeDTO
     */
    'contraseña_actual': string;
    /**
     * La nueva contraseña deseada para la cuenta. Debe tener entre 8 y 100 caracteres.
     * @type {string}
     * @memberof PasswordChangeDTO
     */
    'nueva_contraseña': string;
}
/**
 * DTO para una plataforma de videojuegos.
 * @export
 * @interface PlatformDto
 */
export interface PlatformDto {
    /**
     * Nombre principal de la plataforma.
     * @type {string}
     * @memberof PlatformDto
     */
    'name'?: string;
    /**
     * ID de la plataforma desde IGDB.
     * @type {number}
     * @memberof PlatformDto
     */
    'id'?: number;
    /**
     * Nombre alternativo de la plataforma.
     * @type {string}
     * @memberof PlatformDto
     */
    'alternative_name'?: string | null;
    /**
     * 
     * @type {PlatformLogoDto}
     * @memberof PlatformDto
     */
    'platform_logo'?: PlatformLogoDto;
}
/**
 * DTO para el logo de una plataforma de videojuegos.
 * @export
 * @interface PlatformLogoDto
 */
export interface PlatformLogoDto {
    /**
     * URL de la imagen del logo de la plataforma.
     * @type {string}
     * @memberof PlatformLogoDto
     */
    'url'?: string;
    /**
     * ID del logo desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof PlatformLogoDto
     */
    'id'?: number;
}
/**
 * DTO que representa un comentario público sobre un juego.
 * @export
 * @interface PublicGameCommentDTO
 */
export interface PublicGameCommentDTO {
    /**
     * Nombre de usuario del autor del comentario.
     * @type {string}
     * @memberof PublicGameCommentDTO
     */
    'username'?: string;
    /**
     * ID público del usuario autor del comentario.
     * @type {string}
     * @memberof PublicGameCommentDTO
     */
    'user_public_id'?: string;
    /**
     * Texto del comentario.
     * @type {string}
     * @memberof PublicGameCommentDTO
     */
    'comment_text'?: string;
    /**
     * Fecha y hora de la última actualización del comentario (proveniente de UserGame.updatedAt).
     * @type {string}
     * @memberof PublicGameCommentDTO
     */
    'comment_date'?: string;
}
/**
 * Respuesta específica para errores de validación de campos obligatorios (HTTP 400).
 * @export
 * @interface RequiredErrorResponse
 */
export interface RequiredErrorResponse {
    /**
     * Mensaje de error genérico para campos obligatorios.
     * @type {Array<string>}
     * @memberof RequiredErrorResponse
     */
    'errors'?: Array<string>;
}
/**
 * DTO para la solicitud de restablecimiento de contraseña. Contiene el token recibido por email y la nueva contraseña.
 * @export
 * @interface ResetPasswordDTO
 */
export interface ResetPasswordDTO {
    /**
     * El token de restablecimiento único que el usuario recibió por correo electrónico.
     * @type {string}
     * @memberof ResetPasswordDTO
     */
    'token': string;
    /**
     * La nueva contraseña deseada para la cuenta. Debe tener entre 8 y 100 caracteres.
     * @type {string}
     * @memberof ResetPasswordDTO
     */
    'nueva_contraseña': string;
}
/**
 * DTO para una captura de pantalla de un juego.
 * @export
 * @interface ScreenshotDto
 */
export interface ScreenshotDto {
    /**
     * URL de la imagen de la captura de pantalla.
     * @type {string}
     * @memberof ScreenshotDto
     */
    'url'?: string;
    /**
     * ID de la captura de pantalla desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof ScreenshotDto
     */
    'id'?: number;
}
/**
 * DTO con información resumida de un juego similar.
 * @export
 * @interface SimilarGameInfoDto
 */
export interface SimilarGameInfoDto {
    /**
     * 
     * @type {CoverDto}
     * @memberof SimilarGameInfoDto
     */
    'cover'?: CoverDto;
    /**
     * Nombre del juego similar.
     * @type {string}
     * @memberof SimilarGameInfoDto
     */
    'name'?: string;
    /**
     * Slug del juego similar.
     * @type {string}
     * @memberof SimilarGameInfoDto
     */
    'slug'?: string;
    /**
     * Resumen del juego similar.
     * @type {string}
     * @memberof SimilarGameInfoDto
     */
    'summary'?: string | null;
    /**
     * ID del juego similar desde IGDB.
     * @type {number}
     * @memberof SimilarGameInfoDto
     */
    'id'?: number;
    /**
     * Calificación total del juego similar.
     * @type {number}
     * @memberof SimilarGameInfoDto
     */
    'total_rating'?: number | null;
}
/**
 * DTO para un tema asociado a un videojuego.
 * @export
 * @interface ThemeDto
 */
export interface ThemeDto {
    /**
     * Nombre del tema.
     * @type {string}
     * @memberof ThemeDto
     */
    'name'?: string;
    /**
     * ID del tema desde IGDB.
     * @type {number}
     * @memberof ThemeDto
     */
    'id'?: number;
}
/**
 * DTO para crear una nueva Tier List. Se utiliza principalmente para Tier Lists de perfil.
 * @export
 * @interface TierListCreateRequestDTO
 */
export interface TierListCreateRequestDTO {
    /**
     * Nombre de la Tier List. Debe tener entre 1 y 150 caracteres.
     * @type {string}
     * @memberof TierListCreateRequestDTO
     */
    'name': string;
    /**
     * Descripción opcional para la Tier List. Máximo 1000 caracteres.
     * @type {string}
     * @memberof TierListCreateRequestDTO
     */
    'description'?: string | null;
    /**
     * Indica si la Tier List será pública (true) o privada (false). Por defecto es false (privada).
     * @type {boolean}
     * @memberof TierListCreateRequestDTO
     */
    'is_public'?: boolean | null;
}
/**
 * DTO para añadir un ítem (juego de la biblioteca del usuario) a una sección de una Tier List.
 * @export
 * @interface TierListItemAddRequestDTO
 */
export interface TierListItemAddRequestDTO {
    /**
     * ID interno de la entrada \'UserGame\' (juego en la biblioteca del usuario) que se desea añadir o mover. Es obligatorio.
     * @type {number}
     * @memberof TierListItemAddRequestDTO
     */
    'user_game_id': number;
    /**
     * Posición (orden basado en cero) deseada para el ítem dentro de la sección destino. Si es nulo o está fuera de rango, el ítem se añadirá al final de la sección. Opcional.
     * @type {number}
     * @memberof TierListItemAddRequestDTO
     */
    'order'?: number | null;
}
/**
 * DTO con información de un juego para un ítem de Tier List.
 * @export
 * @interface TierListItemGameInfoDTO
 */
export interface TierListItemGameInfoDTO {
    /**
     * ID interno del ítem en la Tier List.
     * @type {number}
     * @memberof TierListItemGameInfoDTO
     */
    'tier_list_item_id'?: number;
    /**
     * ID interno de la entrada UserGame asociada.
     * @type {number}
     * @memberof TierListItemGameInfoDTO
     */
    'user_game_id'?: number;
    /**
     * ID de IGDB del juego.
     * @type {number}
     * @memberof TierListItemGameInfoDTO
     */
    'game_igdb_id'?: number;
    /**
     * Nombre del juego.
     * @type {string}
     * @memberof TierListItemGameInfoDTO
     */
    'game_name'?: string;
    /**
     * URL de la carátula del juego.
     * @type {string}
     * @memberof TierListItemGameInfoDTO
     */
    'game_cover_url'?: string | null;
    /**
     * Orden del ítem dentro de su sección.
     * @type {number}
     * @memberof TierListItemGameInfoDTO
     */
    'item_order'?: number;
}
/**
 * DTO para especificar el movimiento de un ítem (juego) a una nueva sección y/o posición dentro de una Tier List.
 * @export
 * @interface TierListItemMoveRequestDTO
 */
export interface TierListItemMoveRequestDTO {
    /**
     * ID interno de la sección (tier) destino a la que se moverá el ítem. Es obligatorio.
     * @type {number}
     * @memberof TierListItemMoveRequestDTO
     */
    'target_section_internal_id': number;
    /**
     * Nueva posición (orden basado en cero) para el ítem dentro de la sección destino. Es obligatorio.
     * @type {number}
     * @memberof TierListItemMoveRequestDTO
     */
    'new_order': number;
}
/**
 * DTO que representa una Tier List, incluyendo sus secciones y los ítems (juegos) clasificados en ellas.
 * @export
 * @interface TierListResponseDTO
 */
export interface TierListResponseDTO {
    /**
     * ID público único de la Tier List.
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'public_id'?: string;
    /**
     * Nombre de la Tier List.
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'name'?: string;
    /**
     * Descripción detallada de la Tier List.
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'description'?: string | null;
    /**
     * Tipo de Tier List (ej. general de perfil o basada en una GameList).
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'type'?: TierListResponseDTOTypeEnum;
    /**
     * ID público de la GameList origen, si esta Tier List se generó a partir de una. Nulo para Tier Lists de perfil global.
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'source_game_list_public_id'?: string | null;
    /**
     * Nombre de usuario del propietario de la Tier List.
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'owner_username'?: string;
    /**
     * Indica si la Tier List es pública (true) o privada (false).
     * @type {boolean}
     * @memberof TierListResponseDTO
     */
    'is_public'?: boolean;
    /**
     * Lista de secciones (tiers) definidas por el usuario, ordenadas. No incluye la sección \'Sin Clasificar\'.
     * @type {Array<TierSectionResponseDTO>}
     * @memberof TierListResponseDTO
     */
    'sections'?: Array<TierSectionResponseDTO> | null;
    /**
     * 
     * @type {TierSectionResponseDTO}
     * @memberof TierListResponseDTO
     */
    'unclassified_section'?: TierSectionResponseDTO | null;
    /**
     * Fecha y hora de creación de la Tier List (formato ISO 8601).
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'created_at'?: string;
    /**
     * Fecha y hora de la última actualización de la Tier List (formato ISO 8601).
     * @type {string}
     * @memberof TierListResponseDTO
     */
    'updated_at'?: string;
}

export const TierListResponseDTOTypeEnum = {
    ProfileGlobal: 'PROFILE_GLOBAL',
    FromGamelist: 'FROM_GAMELIST'
} as const;

export type TierListResponseDTOTypeEnum = typeof TierListResponseDTOTypeEnum[keyof typeof TierListResponseDTOTypeEnum];

/**
 * DTO para actualizar los metadatos de una Tier List existente (nombre, descripción, visibilidad). Solo los campos proporcionados (no nulos) serán actualizados.
 * @export
 * @interface TierListUpdateRequestDTO
 */
export interface TierListUpdateRequestDTO {
    /**
     * Nuevo nombre para la Tier List. Si se proporciona, debe tener entre 1 y 150 caracteres.
     * @type {string}
     * @memberof TierListUpdateRequestDTO
     */
    'name'?: string | null;
    /**
     * Nueva descripción para la Tier List. Si se proporciona, no puede exceder los 1000 caracteres.
     * @type {string}
     * @memberof TierListUpdateRequestDTO
     */
    'description'?: string | null;
    /**
     * Nuevo estado de visibilidad para la Tier List (true para pública, false para privada). Si se proporciona, se actualizará el estado.
     * @type {boolean}
     * @memberof TierListUpdateRequestDTO
     */
    'is_public'?: boolean | null;
}
/**
 * DTO para solicitar la creación o actualización del nombre de una nueva sección (tier) dentro de una Tier List.
 * @export
 * @interface TierSectionRequestDTO
 */
export interface TierSectionRequestDTO {
    /**
     * Nombre de la nueva sección (tier). Debe tener entre 1 y 100 caracteres.
     * @type {string}
     * @memberof TierSectionRequestDTO
     */
    'name': string;
    /**
     * Color de la sección (tier) en formato hexadecimal.
     * @type {string}
     * @memberof TierSectionRequestDTO
     */
    'color': string;
}
/**
 * DTO para una sección (tier) de una Tier List, incluyendo sus ítems.
 * @export
 * @interface TierSectionResponseDTO
 */
export interface TierSectionResponseDTO {
    /**
     * ID interno de la sección.
     * @type {number}
     * @memberof TierSectionResponseDTO
     */
    'internal_id'?: number;
    /**
     * Nombre de la sección.
     * @type {string}
     * @memberof TierSectionResponseDTO
     */
    'name'?: string;
    /**
     * Color de la sección en formato hexadecimal.
     * @type {string}
     * @memberof TierSectionResponseDTO
     */
    'color'?: string | null;
    /**
     * Orden de la sección dentro de la Tier List.
     * @type {number}
     * @memberof TierSectionResponseDTO
     */
    'order'?: number;
    /**
     * Indica si es la sección por defecto para ítems sin clasificar.
     * @type {boolean}
     * @memberof TierSectionResponseDTO
     */
    'is_default_unclassified'?: boolean;
    /**
     * Lista de ítems (juegos) en esta sección.
     * @type {Array<TierListItemGameInfoDTO>}
     * @memberof TierSectionResponseDTO
     */
    'items'?: Array<TierListItemGameInfoDTO>;
}
/**
 * Respuesta específica para errores de tamaño de payload excedido (HTTP 413).
 * @export
 * @interface TooLargeResponse
 */
export interface TooLargeResponse {
    /**
     * Mensaje de error para archivos que exceden el tamaño permitido.
     * @type {Array<string>}
     * @memberof TooLargeResponse
     */
    'errors'?: Array<string>;
}
/**
 * Respuesta específica para errores de autorización (HTTP 401).
 * @export
 * @interface UnauthorizedResponse
 */
export interface UnauthorizedResponse {
    /**
     * Mensaje de error indicando que la autenticación falló.
     * @type {string}
     * @memberof UnauthorizedResponse
     */
    'message'?: string;
}
/**
 * DTO para la creación de un nuevo usuario. Contiene los campos obligatorios para el registro.
 * @export
 * @interface UserCreateDTO
 */
export interface UserCreateDTO {
    /**
     * Nombre de usuario único para la cuenta. Debe tener entre 3 y 100 caracteres.
     * @type {string}
     * @memberof UserCreateDTO
     */
    'nombre_usuario': string;
    /**
     * Dirección de correo electrónico del usuario. Debe ser única y tener un formato válido.
     * @type {string}
     * @memberof UserCreateDTO
     */
    'email': string;
    /**
     * Contraseña para la cuenta del usuario. Debe tener entre 8 y 100 caracteres.
     * @type {string}
     * @memberof UserCreateDTO
     */
    'contraseña': string;
}
/**
 * DTO que representa la información pública y de preferencias de un usuario. Se devuelve tras un registro o al solicitar datos de usuario.
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * Identificador público único del usuario, generado automáticamente.
     * @type {string}
     * @memberof UserDTO
     */
    'public_id'?: string;
    /**
     * Nombre de usuario elegido por el usuario.
     * @type {string}
     * @memberof UserDTO
     */
    'nombre_usuario'?: string;
    /**
     * Dirección de correo electrónico del usuario.
     * @type {string}
     * @memberof UserDTO
     */
    'email'?: string;
    /**
     * Fecha y hora en que el usuario se registró en el sistema (formato ISO 8601).
     * @type {string}
     * @memberof UserDTO
     */
    'fecha_registro'?: string;
    /**
     * Tema de la interfaz preferido por el usuario.
     * @type {string}
     * @memberof UserDTO
     */
    'tema'?: UserDTOTemaEnum;
    /**
     * URL relativa o absoluta de la foto de perfil del usuario. Puede ser nulo si no se ha subido ninguna.
     * @type {string}
     * @memberof UserDTO
     */
    'foto_perfil'?: string | null;
    /**
     * Indica si el usuario desea recibir notificaciones. Por defecto es true.
     * @type {boolean}
     * @memberof UserDTO
     */
    'notificaciones'?: boolean;
    /**
     * Nivel de visibilidad del perfil del usuario. Por defecto es PUBLICO.
     * @type {string}
     * @memberof UserDTO
     */
    'visibilidad_perfil'?: UserDTOVisibilidadPerfilEnum;
}

export const UserDTOTemaEnum = {
    Claro: 'CLARO',
    Oscuro: 'OSCURO',
    Claro2: 'CLARO',
    Oscuro2: 'OSCURO'
} as const;

export type UserDTOTemaEnum = typeof UserDTOTemaEnum[keyof typeof UserDTOTemaEnum];
export const UserDTOVisibilidadPerfilEnum = {
    Publico: 'PUBLICO',
    Privado: 'PRIVADO',
    SoloAmigos: 'SOLO_AMIGOS',
    Publico2: 'PUBLICO',
    Privado2: 'PRIVADO',
    SoloAmigos2: 'SOLO_AMIGOS'
} as const;

export type UserDTOVisibilidadPerfilEnum = typeof UserDTOVisibilidadPerfilEnum[keyof typeof UserDTOVisibilidadPerfilEnum];

/**
 * DTO para proporcionar o actualizar los datos específicos de un usuario para un juego en su biblioteca.
 * @export
 * @interface UserGameDataDTO
 */
export interface UserGameDataDTO {
    /**
     * Estado del juego en la biblioteca del usuario (ej. JUGANDO, COMPLETADO).
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'status'?: UserGameDataDTOStatusEnum | null;
    /**
     * Plataforma personal en la que el usuario juega o posee el juego.
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'personal_platform'?: UserGameDataDTOPersonalPlatformEnum | null;
    /**
     * Indica si el usuario posee físicamente o digitalmente el juego.
     * @type {boolean}
     * @memberof UserGameDataDTO
     */
    'has_possession'?: boolean | null;
    /**
     * Puntuación personal otorgada por el usuario al juego (ej. de 0.0 a 10.0).
     * @type {number}
     * @memberof UserGameDataDTO
     */
    'score'?: number | null;
    /**
     * Comentario público del usuario sobre el juego. Máximo 2000 caracteres.
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'comment'?: string | null;
    /**
     * Comentario privado del usuario sobre el juego (solo visible para él). Máximo 2000 caracteres.
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'private_comment'?: string | null;
    /**
     * Fecha en la que el usuario comenzó a jugar el juego (formato YYYY-MM-DD).
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'start_date'?: string | null;
    /**
     * Fecha en la que el usuario terminó de jugar el juego (formato YYYY-MM-DD).
     * @type {string}
     * @memberof UserGameDataDTO
     */
    'end_date'?: string | null;
    /**
     * Duración estimada en horas para completar la historia principal.
     * @type {number}
     * @memberof UserGameDataDTO
     */
    'story_duration_hours'?: number | null;
    /**
     * Duración estimada en horas para completar la historia principal y misiones secundarias importantes.
     * @type {number}
     * @memberof UserGameDataDTO
     */
    'story_secondary_duration_hours'?: number | null;
    /**
     * Duración estimada en horas para completar el juego al 100%.
     * @type {number}
     * @memberof UserGameDataDTO
     */
    'completionist_duration_hours'?: number | null;
}

export const UserGameDataDTOStatusEnum = {
    Completed: 'COMPLETED',
    CompletedMainStory: 'COMPLETED_MAIN_STORY',
    CompletedMainAndSides: 'COMPLETED_MAIN_AND_SIDES',
    Completed100Percent: 'COMPLETED_100_PERCENT',
    Archived: 'ARCHIVED',
    ArchivedAbandoned: 'ARCHIVED_ABANDONED',
    ArchivedNotPlaying: 'ARCHIVED_NOT_PLAYING',
    Wishlist: 'WISHLIST',
    Playing: 'PLAYING',
    PlayingPaused: 'PLAYING_PAUSED',
    PlayingEndless: 'PLAYING_ENDLESS'
} as const;

export type UserGameDataDTOStatusEnum = typeof UserGameDataDTOStatusEnum[keyof typeof UserGameDataDTOStatusEnum];
export const UserGameDataDTOPersonalPlatformEnum = {
    Steam: 'STEAM',
    EpicGames: 'EPIC_GAMES',
    GogGalaxy: 'GOG_GALAXY',
    Xbox: 'XBOX',
    Playstation: 'PLAYSTATION',
    Nintendo: 'NINTENDO',
    BattleNet: 'BATTLE_NET',
    EaApp: 'EA_APP',
    UbisoftConnect: 'UBISOFT_CONNECT',
    Other: 'OTHER'
} as const;

export type UserGameDataDTOPersonalPlatformEnum = typeof UserGameDataDTOPersonalPlatformEnum[keyof typeof UserGameDataDTOPersonalPlatformEnum];

/**
 * DTO que representa una entrada en la biblioteca de juegos de un usuario, incluyendo sus datos personales sobre un juego específico.
 * @export
 * @interface UserGameResponseDTO
 */
export interface UserGameResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'internal_id'?: number;
    /**
     * ID de IGDB del juego al que se refiere esta entrada de la biblioteca.
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'game_igdb_id'?: number;
    /**
     * Nombre del juego.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'game_name'?: string;
    /**
     * 
     * @type {CoverDto}
     * @memberof UserGameResponseDTO
     */
    'game_cover'?: CoverDto;
    /**
     * Estado actual del juego en la biblioteca del usuario.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'status'?: UserGameResponseDTOStatusEnum;
    /**
     * Plataforma personal en la que el usuario juega o posee el juego.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'personal_platform'?: UserGameResponseDTOPersonalPlatformEnum;
    /**
     * Indica si el usuario posee el juego.
     * @type {boolean}
     * @memberof UserGameResponseDTO
     */
    'has_possession'?: boolean;
    /**
     * Puntuación personal otorgada por el usuario al juego.
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'score'?: number;
    /**
     * Comentario público del usuario sobre el juego.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'comment'?: string | null;
    /**
     * Comentario privado del usuario sobre el juego (no visible para otros).
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'private_comment'?: string | null;
    /**
     * Fecha en que el usuario comenzó a jugar (YYYY-MM-DD).
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'start_date'?: string | null;
    /**
     * Fecha en que el usuario terminó de jugar (YYYY-MM-DD).
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'end_date'?: string | null;
    /**
     * Horas dedicadas a la historia principal.
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'story_duration_hours'?: number | null;
    /**
     * Horas dedicadas a la historia principal y secundarias.
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'story_secondary_duration_hours'?: number | null;
    /**
     * Horas dedicadas para completar el juego al 100%.
     * @type {number}
     * @memberof UserGameResponseDTO
     */
    'completionist_duration_hours'?: number | null;
    /**
     * Fecha y hora de creación de esta entrada en la biblioteca.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'created_at'?: string;
    /**
     * Fecha y hora de la última actualización de esta entrada.
     * @type {string}
     * @memberof UserGameResponseDTO
     */
    'updated_at'?: string;
}

export const UserGameResponseDTOStatusEnum = {
    Completed: 'COMPLETED',
    CompletedMainStory: 'COMPLETED_MAIN_STORY',
    CompletedMainAndSides: 'COMPLETED_MAIN_AND_SIDES',
    Completed100Percent: 'COMPLETED_100_PERCENT',
    Archived: 'ARCHIVED',
    ArchivedAbandoned: 'ARCHIVED_ABANDONED',
    ArchivedNotPlaying: 'ARCHIVED_NOT_PLAYING',
    Wishlist: 'WISHLIST',
    Playing: 'PLAYING',
    PlayingPaused: 'PLAYING_PAUSED',
    PlayingEndless: 'PLAYING_ENDLESS'
} as const;

export type UserGameResponseDTOStatusEnum = typeof UserGameResponseDTOStatusEnum[keyof typeof UserGameResponseDTOStatusEnum];
export const UserGameResponseDTOPersonalPlatformEnum = {
    Steam: 'STEAM',
    EpicGames: 'EPIC_GAMES',
    GogGalaxy: 'GOG_GALAXY',
    Xbox: 'XBOX',
    Playstation: 'PLAYSTATION',
    Nintendo: 'NINTENDO',
    BattleNet: 'BATTLE_NET',
    EaApp: 'EA_APP',
    UbisoftConnect: 'UBISOFT_CONNECT',
    Other: 'OTHER'
} as const;

export type UserGameResponseDTOPersonalPlatformEnum = typeof UserGameResponseDTOPersonalPlatformEnum[keyof typeof UserGameResponseDTOPersonalPlatformEnum];

/**
 * DTO para actualizar el perfil de un usuario. Solo los campos presentes y no nulos (o que cumplan @NotNull) serán considerados para la actualización. Para campos como \'foto_perfil\', enviar un nuevo valor actualiza, enviar null o no enviar el campo lo deja sin cambios.
 * @export
 * @interface UserProfileUpdateDTO
 */
export interface UserProfileUpdateDTO {
    /**
     * Nuevo nombre de usuario para la cuenta. Si se proporciona, debe tener entre 3 y 100 caracteres. Si no se envía o es nulo, no se actualiza.
     * @type {string}
     * @memberof UserProfileUpdateDTO
     */
    'nombre_usuario'?: string | null;
    /**
     * Nuevo tema de la interfaz preferido por el usuario. Si no se envía o es nulo, no se actualiza.
     * @type {string}
     * @memberof UserProfileUpdateDTO
     */
    'tema'?: UserProfileUpdateDTOTemaEnum | null;
    /**
     * Nueva URL de la foto de perfil del usuario. Este campo normalmente se actualiza a través del endpoint de subida de imágenes. Si se proporciona aquí, debería ser una URL válida a una imagen ya alojada. Si no se envía o es nulo, no se actualiza.
     * @type {string}
     * @memberof UserProfileUpdateDTO
     */
    'foto_perfil'?: string | null;
    /**
     * Preferencia para recibir notificaciones. Si se envía, no puede ser nulo.
     * @type {boolean}
     * @memberof UserProfileUpdateDTO
     */
    'notificaciones': boolean | null;
    /**
     * Nuevo nivel de visibilidad del perfil del usuario. Si no se envía o es nulo, no se actualiza.
     * @type {string}
     * @memberof UserProfileUpdateDTO
     */
    'visibilidad_perfil'?: UserProfileUpdateDTOVisibilidadPerfilEnum | null;
}

export const UserProfileUpdateDTOTemaEnum = {
    Claro: 'CLARO',
    Oscuro: 'OSCURO',
    Claro2: 'CLARO',
    Oscuro2: 'OSCURO'
} as const;

export type UserProfileUpdateDTOTemaEnum = typeof UserProfileUpdateDTOTemaEnum[keyof typeof UserProfileUpdateDTOTemaEnum];
export const UserProfileUpdateDTOVisibilidadPerfilEnum = {
    Publico: 'PUBLICO',
    Privado: 'PRIVADO',
    SoloAmigos: 'SOLO_AMIGOS',
    Publico2: 'PUBLICO',
    Privado2: 'PRIVADO',
    SoloAmigos2: 'SOLO_AMIGOS'
} as const;

export type UserProfileUpdateDTOVisibilidadPerfilEnum = typeof UserProfileUpdateDTOVisibilidadPerfilEnum[keyof typeof UserProfileUpdateDTOVisibilidadPerfilEnum];

/**
 * DTO que representa un resultado de búsqueda de usuario, mostrando información pública básica.
 * @export
 * @interface UserSearchResultDTO
 */
export interface UserSearchResultDTO {
    /**
     * ID público del usuario encontrado.
     * @type {string}
     * @memberof UserSearchResultDTO
     */
    'public_id'?: string;
    /**
     * Nombre de usuario del usuario encontrado.
     * @type {string}
     * @memberof UserSearchResultDTO
     */
    'nombre_usuario'?: string;
    /**
     * URL de la foto de perfil del usuario encontrado. Puede ser nulo.
     * @type {string}
     * @memberof UserSearchResultDTO
     */
    'foto_perfil'?: string | null;
}
/**
 * Respuesta específica para errores de validación de campos (HTTP 400).
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     * Lista de mensajes de error de validación.
     * @type {Array<string>}
     * @memberof ValidationErrorResponse
     */
    'errors'?: Array<string>;
}
/**
 * Respuesta específica para errores de validación de campos relacionados con contraseñas (HTTP 400).
 * @export
 * @interface ValidationPasswordErrorResponse
 */
export interface ValidationPasswordErrorResponse {
    /**
     * Lista de mensajes de error de validación.
     * @type {Array<string>}
     * @memberof ValidationPasswordErrorResponse
     */
    'errors'?: Array<string>;
}
/**
 * DTO para un vídeo asociado a un juego.
 * @export
 * @interface VideoDto
 */
export interface VideoDto {
    /**
     * Nombre o título del vídeo.
     * @type {string}
     * @memberof VideoDto
     */
    'name'?: string;
    /**
     * ID del vídeo desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof VideoDto
     */
    'id'?: number;
    /**
     * Identificador del vídeo en la plataforma de origen (ej. ID de YouTube).
     * @type {string}
     * @memberof VideoDto
     */
    'video_id'?: string;
}
/**
 * DTO para un sitio web asociado a un juego.
 * @export
 * @interface WebsiteDto
 */
export interface WebsiteDto {
    /**
     * URL completa del sitio web.
     * @type {string}
     * @memberof WebsiteDto
     */
    'url'?: string;
    /**
     * ID del sitio web desde la fuente externa (ej. IGDB).
     * @type {number}
     * @memberof WebsiteDto
     */
    'id'?: number;
}

/**
 * AutenticacinControllerApi - axios parameter creator
 * @export
 */
export const AutenticacinControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite a un usuario iniciar sesión proporcionando su identificador (email o nombre de usuario) y contraseña. Si las credenciales son válidas y la cuenta está activa, se devuelve un token JWT. Si el usuario tenía una eliminación de cuenta programada y la fecha aún no ha pasado, esta se cancela.
         * @summary Autenticar usuario y obtener token JWT
         * @param {LoginRequestDTO} loginRequestDTO Credenciales del usuario para iniciar sesión.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (loginRequestDTO: LoginRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestDTO' is not null or undefined
            assertParamExists('authenticateUser', 'loginRequestDTO', loginRequestDTO)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Valida un token de verificación enviado al correo electrónico del usuario tras el registro. Si el token es válido y no ha expirado, la cuenta del usuario se marca como verificada. Este endpoint es público y se accede a través del enlace en el correo de verificación.
         * @summary Confirmar la dirección de correo electrónico de un usuario
         * @param {string} token El token de verificación único enviado al correo electrónico del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAccount: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('confirmUserAccount', 'token', token)
            const localVarPath = `/api/v1/auth/confirm-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inicia el proceso para restablecer la contraseña de un usuario. El usuario proporciona su dirección de correo electrónico. Si el correo está registrado, se enviará un email con un token e instrucciones para restablecer la contraseña. Para no revelar si un email existe en el sistema, este endpoint siempre devuelve una respuesta genérica de éxito, independientemente de si el email fue encontrado o no. Este endpoint es público.
         * @summary Solicitar restablecimiento de contraseña
         * @param {ForgotPasswordDTO} forgotPasswordDTO DTO que contiene el correo electrónico del usuario que ha olvidado su contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordDTO: ForgotPasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDTO' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordDTO', forgotPasswordDTO)
            const localVarPath = `/api/v1/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite a un usuario establecer una nueva contraseña utilizando el token de restablecimiento que recibió por correo electrónico. El token debe ser válido y no haber expirado. Este endpoint es público.
         * @summary Restablecer la contraseña del usuario utilizando un token
         * @param {ResetPasswordDTO} resetPasswordDTO DTO que contiene el token de restablecimiento y la nueva contraseña deseada.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordDTO: ResetPasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDTO' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordDTO', resetPasswordDTO)
            const localVarPath = `/api/v1/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutenticacinControllerApi - functional programming interface
 * @export
 */
export const AutenticacinControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutenticacinControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite a un usuario iniciar sesión proporcionando su identificador (email o nombre de usuario) y contraseña. Si las credenciales son válidas y la cuenta está activa, se devuelve un token JWT. Si el usuario tenía una eliminación de cuenta programada y la fecha aún no ha pasado, esta se cancela.
         * @summary Autenticar usuario y obtener token JWT
         * @param {LoginRequestDTO} loginRequestDTO Credenciales del usuario para iniciar sesión.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateUser(loginRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinControllerApi.authenticateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Valida un token de verificación enviado al correo electrónico del usuario tras el registro. Si el token es válido y no ha expirado, la cuenta del usuario se marca como verificada. Este endpoint es público y se accede a través del enlace en el correo de verificación.
         * @summary Confirmar la dirección de correo electrónico de un usuario
         * @param {string} token El token de verificación único enviado al correo electrónico del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmUserAccount(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmUserAccount(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinControllerApi.confirmUserAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inicia el proceso para restablecer la contraseña de un usuario. El usuario proporciona su dirección de correo electrónico. Si el correo está registrado, se enviará un email con un token e instrucciones para restablecer la contraseña. Para no revelar si un email existe en el sistema, este endpoint siempre devuelve una respuesta genérica de éxito, independientemente de si el email fue encontrado o no. Este endpoint es público.
         * @summary Solicitar restablecimiento de contraseña
         * @param {ForgotPasswordDTO} forgotPasswordDTO DTO que contiene el correo electrónico del usuario que ha olvidado su contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordDTO: ForgotPasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinControllerApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite a un usuario establecer una nueva contraseña utilizando el token de restablecimiento que recibió por correo electrónico. El token debe ser válido y no haber expirado. Este endpoint es público.
         * @summary Restablecer la contraseña del usuario utilizando un token
         * @param {ResetPasswordDTO} resetPasswordDTO DTO que contiene el token de restablecimiento y la nueva contraseña deseada.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordDTO: ResetPasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutenticacinControllerApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutenticacinControllerApi - factory interface
 * @export
 */
export const AutenticacinControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutenticacinControllerApiFp(configuration)
    return {
        /**
         * Permite a un usuario iniciar sesión proporcionando su identificador (email o nombre de usuario) y contraseña. Si las credenciales son válidas y la cuenta está activa, se devuelve un token JWT. Si el usuario tenía una eliminación de cuenta programada y la fecha aún no ha pasado, esta se cancela.
         * @summary Autenticar usuario y obtener token JWT
         * @param {LoginRequestDTO} loginRequestDTO Credenciales del usuario para iniciar sesión.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<JwtResponseDTO> {
            return localVarFp.authenticateUser(loginRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Valida un token de verificación enviado al correo electrónico del usuario tras el registro. Si el token es válido y no ha expirado, la cuenta del usuario se marca como verificada. Este endpoint es público y se accede a través del enlace en el correo de verificación.
         * @summary Confirmar la dirección de correo electrónico de un usuario
         * @param {string} token El token de verificación único enviado al correo electrónico del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAccount(token: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.confirmUserAccount(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Inicia el proceso para restablecer la contraseña de un usuario. El usuario proporciona su dirección de correo electrónico. Si el correo está registrado, se enviará un email con un token e instrucciones para restablecer la contraseña. Para no revelar si un email existe en el sistema, este endpoint siempre devuelve una respuesta genérica de éxito, independientemente de si el email fue encontrado o no. Este endpoint es público.
         * @summary Solicitar restablecimiento de contraseña
         * @param {ForgotPasswordDTO} forgotPasswordDTO DTO que contiene el correo electrónico del usuario que ha olvidado su contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(forgotPasswordDTO: ForgotPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.forgotPassword(forgotPasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite a un usuario establecer una nueva contraseña utilizando el token de restablecimiento que recibió por correo electrónico. El token debe ser válido y no haber expirado. Este endpoint es público.
         * @summary Restablecer la contraseña del usuario utilizando un token
         * @param {ResetPasswordDTO} resetPasswordDTO DTO que contiene el token de restablecimiento y la nueva contraseña deseada.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(resetPasswordDTO: ResetPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.resetPassword(resetPasswordDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutenticacinControllerApi - interface
 * @export
 * @interface AutenticacinControllerApi
 */
export interface AutenticacinControllerApiInterface {
    /**
     * Permite a un usuario iniciar sesión proporcionando su identificador (email o nombre de usuario) y contraseña. Si las credenciales son válidas y la cuenta está activa, se devuelve un token JWT. Si el usuario tenía una eliminación de cuenta programada y la fecha aún no ha pasado, esta se cancela.
     * @summary Autenticar usuario y obtener token JWT
     * @param {LoginRequestDTO} loginRequestDTO Credenciales del usuario para iniciar sesión.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApiInterface
     */
    authenticateUser(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<JwtResponseDTO>;

    /**
     * Valida un token de verificación enviado al correo electrónico del usuario tras el registro. Si el token es válido y no ha expirado, la cuenta del usuario se marca como verificada. Este endpoint es público y se accede a través del enlace en el correo de verificación.
     * @summary Confirmar la dirección de correo electrónico de un usuario
     * @param {string} token El token de verificación único enviado al correo electrónico del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApiInterface
     */
    confirmUserAccount(token: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

    /**
     * Inicia el proceso para restablecer la contraseña de un usuario. El usuario proporciona su dirección de correo electrónico. Si el correo está registrado, se enviará un email con un token e instrucciones para restablecer la contraseña. Para no revelar si un email existe en el sistema, este endpoint siempre devuelve una respuesta genérica de éxito, independientemente de si el email fue encontrado o no. Este endpoint es público.
     * @summary Solicitar restablecimiento de contraseña
     * @param {ForgotPasswordDTO} forgotPasswordDTO DTO que contiene el correo electrónico del usuario que ha olvidado su contraseña.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApiInterface
     */
    forgotPassword(forgotPasswordDTO: ForgotPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Permite a un usuario establecer una nueva contraseña utilizando el token de restablecimiento que recibió por correo electrónico. El token debe ser válido y no haber expirado. Este endpoint es público.
     * @summary Restablecer la contraseña del usuario utilizando un token
     * @param {ResetPasswordDTO} resetPasswordDTO DTO que contiene el token de restablecimiento y la nueva contraseña deseada.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApiInterface
     */
    resetPassword(resetPasswordDTO: ResetPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * AutenticacinControllerApi - object-oriented interface
 * @export
 * @class AutenticacinControllerApi
 * @extends {BaseAPI}
 */
export class AutenticacinControllerApi extends BaseAPI implements AutenticacinControllerApiInterface {
    /**
     * Permite a un usuario iniciar sesión proporcionando su identificador (email o nombre de usuario) y contraseña. Si las credenciales son válidas y la cuenta está activa, se devuelve un token JWT. Si el usuario tenía una eliminación de cuenta programada y la fecha aún no ha pasado, esta se cancela.
     * @summary Autenticar usuario y obtener token JWT
     * @param {LoginRequestDTO} loginRequestDTO Credenciales del usuario para iniciar sesión.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApi
     */
    public authenticateUser(loginRequestDTO: LoginRequestDTO, options?: RawAxiosRequestConfig) {
        return AutenticacinControllerApiFp(this.configuration).authenticateUser(loginRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Valida un token de verificación enviado al correo electrónico del usuario tras el registro. Si el token es válido y no ha expirado, la cuenta del usuario se marca como verificada. Este endpoint es público y se accede a través del enlace en el correo de verificación.
     * @summary Confirmar la dirección de correo electrónico de un usuario
     * @param {string} token El token de verificación único enviado al correo electrónico del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApi
     */
    public confirmUserAccount(token: string, options?: RawAxiosRequestConfig) {
        return AutenticacinControllerApiFp(this.configuration).confirmUserAccount(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inicia el proceso para restablecer la contraseña de un usuario. El usuario proporciona su dirección de correo electrónico. Si el correo está registrado, se enviará un email con un token e instrucciones para restablecer la contraseña. Para no revelar si un email existe en el sistema, este endpoint siempre devuelve una respuesta genérica de éxito, independientemente de si el email fue encontrado o no. Este endpoint es público.
     * @summary Solicitar restablecimiento de contraseña
     * @param {ForgotPasswordDTO} forgotPasswordDTO DTO que contiene el correo electrónico del usuario que ha olvidado su contraseña.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApi
     */
    public forgotPassword(forgotPasswordDTO: ForgotPasswordDTO, options?: RawAxiosRequestConfig) {
        return AutenticacinControllerApiFp(this.configuration).forgotPassword(forgotPasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite a un usuario establecer una nueva contraseña utilizando el token de restablecimiento que recibió por correo electrónico. El token debe ser válido y no haber expirado. Este endpoint es público.
     * @summary Restablecer la contraseña del usuario utilizando un token
     * @param {ResetPasswordDTO} resetPasswordDTO DTO que contiene el token de restablecimiento y la nueva contraseña deseada.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutenticacinControllerApi
     */
    public resetPassword(resetPasswordDTO: ResetPasswordDTO, options?: RawAxiosRequestConfig) {
        return AutenticacinControllerApiFp(this.configuration).resetPassword(resetPasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FriendshipControllerApi - axios parameter creator
 * @export
 */
export const FriendshipControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) aceptar una solicitud de amistad pendiente de otro usuario. La solicitud debe estar en estado PENDIENTE. Requiere autenticación.
         * @summary Aceptar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que envió la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: async (requesterUserPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requesterUserPublicId' is not null or undefined
            assertParamExists('acceptFriendRequest', 'requesterUserPublicId', requesterUserPublicId)
            const localVarPath = `/api/v1/friends/requests/accept/{requesterUserPublicId}`
                .replace(`{${"requesterUserPublicId"}}`, encodeURIComponent(String(requesterUserPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) rechazar una solicitud de amistad pendiente. Alternativamente, si el usuario autenticado fue quien envió la solicitud y esta aún está pendiente, puede usar este endpoint para cancelarla (aunque semánticamente esto último podría ser un endpoint diferente, la lógica actual del servicio elimina la solicitud PENDIENTE). La solicitud de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Rechazar o cancelar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que originalmente envió la solicitud de amistad que se desea rechazar/cancelar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineOrCancelFriendRequest: async (requesterUserPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requesterUserPublicId' is not null or undefined
            assertParamExists('declineOrCancelFriendRequest', 'requesterUserPublicId', requesterUserPublicId)
            const localVarPath = `/api/v1/friends/requests/decline/{requesterUserPublicId}`
                .replace(`{${"requesterUserPublicId"}}`, encodeURIComponent(String(requesterUserPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todos los usuarios que son amigos del usuario actualmente autenticado (es decir, aquellas relaciones con estado \'ACCEPTED\'). Requiere autenticación.
         * @summary Obtener la lista de amigos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFriends: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha recibido y aún están pendientes de acción (aceptar o rechazar). Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes recibidas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequestsReceived: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friends/requests/received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha enviado y que aún están pendientes de respuesta por parte de los destinatarios. Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes enviadas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequestsSent: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/friends/requests/sent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado eliminar una amistad existente con otro usuario, especificado por su ID público. La relación de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Eliminar un amigo
         * @param {string} friendUserPublicId ID público (UUID) del amigo que se desea eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFriend: async (friendUserPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendUserPublicId' is not null or undefined
            assertParamExists('removeFriend', 'friendUserPublicId', friendUserPublicId)
            const localVarPath = `/api/v1/friends/{friendUserPublicId}`
                .replace(`{${"friendUserPublicId"}}`, encodeURIComponent(String(friendUserPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado enviar una solicitud de amistad a otro usuario especificado por su ID público. Si ya existe una solicitud pendiente del receptor hacia el emisor, la amistad se aceptará automáticamente. Requiere autenticación.
         * @summary Enviar una solicitud de amistad
         * @param {string} receiverUserPublicId ID público (UUID) del usuario al que se le envía la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequest: async (receiverUserPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiverUserPublicId' is not null or undefined
            assertParamExists('sendFriendRequest', 'receiverUserPublicId', receiverUserPublicId)
            const localVarPath = `/api/v1/friends/requests/send/{receiverUserPublicId}`
                .replace(`{${"receiverUserPublicId"}}`, encodeURIComponent(String(receiverUserPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendshipControllerApi - functional programming interface
 * @export
 */
export const FriendshipControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FriendshipControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) aceptar una solicitud de amistad pendiente de otro usuario. La solicitud debe estar en estado PENDIENTE. Requiere autenticación.
         * @summary Aceptar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que envió la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendshipResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequest(requesterUserPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.acceptFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) rechazar una solicitud de amistad pendiente. Alternativamente, si el usuario autenticado fue quien envió la solicitud y esta aún está pendiente, puede usar este endpoint para cancelarla (aunque semánticamente esto último podría ser un endpoint diferente, la lógica actual del servicio elimina la solicitud PENDIENTE). La solicitud de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Rechazar o cancelar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que originalmente envió la solicitud de amistad que se desea rechazar/cancelar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineOrCancelFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineOrCancelFriendRequest(requesterUserPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.declineOrCancelFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todos los usuarios que son amigos del usuario actualmente autenticado (es decir, aquellas relaciones con estado \'ACCEPTED\'). Requiere autenticación.
         * @summary Obtener la lista de amigos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyFriends(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FriendshipResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyFriends(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.getMyFriends']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha recibido y aún están pendientes de acción (aceptar o rechazar). Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes recibidas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingRequestsReceived(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FriendshipResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingRequestsReceived(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.getPendingRequestsReceived']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha enviado y que aún están pendientes de respuesta por parte de los destinatarios. Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes enviadas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingRequestsSent(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FriendshipResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingRequestsSent(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.getPendingRequestsSent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado eliminar una amistad existente con otro usuario, especificado por su ID público. La relación de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Eliminar un amigo
         * @param {string} friendUserPublicId ID público (UUID) del amigo que se desea eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFriend(friendUserPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFriend(friendUserPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.removeFriend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado enviar una solicitud de amistad a otro usuario especificado por su ID público. Si ya existe una solicitud pendiente del receptor hacia el emisor, la amistad se aceptará automáticamente. Requiere autenticación.
         * @summary Enviar una solicitud de amistad
         * @param {string} receiverUserPublicId ID público (UUID) del usuario al que se le envía la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFriendRequest(receiverUserPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendshipResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFriendRequest(receiverUserPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendshipControllerApi.sendFriendRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FriendshipControllerApi - factory interface
 * @export
 */
export const FriendshipControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FriendshipControllerApiFp(configuration)
    return {
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) aceptar una solicitud de amistad pendiente de otro usuario. La solicitud debe estar en estado PENDIENTE. Requiere autenticación.
         * @summary Aceptar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que envió la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipResponseDTO> {
            return localVarFp.acceptFriendRequest(requesterUserPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado (que es el receptor de la solicitud) rechazar una solicitud de amistad pendiente. Alternativamente, si el usuario autenticado fue quien envió la solicitud y esta aún está pendiente, puede usar este endpoint para cancelarla (aunque semánticamente esto último podría ser un endpoint diferente, la lógica actual del servicio elimina la solicitud PENDIENTE). La solicitud de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Rechazar o cancelar una solicitud de amistad pendiente
         * @param {string} requesterUserPublicId ID público (UUID) del usuario que originalmente envió la solicitud de amistad que se desea rechazar/cancelar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineOrCancelFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.declineOrCancelFriendRequest(requesterUserPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todos los usuarios que son amigos del usuario actualmente autenticado (es decir, aquellas relaciones con estado \'ACCEPTED\'). Requiere autenticación.
         * @summary Obtener la lista de amigos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>> {
            return localVarFp.getMyFriends(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha recibido y aún están pendientes de acción (aceptar o rechazar). Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes recibidas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequestsReceived(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>> {
            return localVarFp.getPendingRequestsReceived(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha enviado y que aún están pendientes de respuesta por parte de los destinatarios. Requiere autenticación.
         * @summary Obtener las solicitudes de amistad pendientes enviadas por el usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingRequestsSent(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>> {
            return localVarFp.getPendingRequestsSent(options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado eliminar una amistad existente con otro usuario, especificado por su ID público. La relación de amistad es eliminada de la base de datos. Requiere autenticación.
         * @summary Eliminar un amigo
         * @param {string} friendUserPublicId ID público (UUID) del amigo que se desea eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFriend(friendUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFriend(friendUserPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado enviar una solicitud de amistad a otro usuario especificado por su ID público. Si ya existe una solicitud pendiente del receptor hacia el emisor, la amistad se aceptará automáticamente. Requiere autenticación.
         * @summary Enviar una solicitud de amistad
         * @param {string} receiverUserPublicId ID público (UUID) del usuario al que se le envía la solicitud de amistad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequest(receiverUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipResponseDTO> {
            return localVarFp.sendFriendRequest(receiverUserPublicId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FriendshipControllerApi - interface
 * @export
 * @interface FriendshipControllerApi
 */
export interface FriendshipControllerApiInterface {
    /**
     * Permite al usuario autenticado (que es el receptor de la solicitud) aceptar una solicitud de amistad pendiente de otro usuario. La solicitud debe estar en estado PENDIENTE. Requiere autenticación.
     * @summary Aceptar una solicitud de amistad pendiente
     * @param {string} requesterUserPublicId ID público (UUID) del usuario que envió la solicitud de amistad.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    acceptFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipResponseDTO>;

    /**
     * Permite al usuario autenticado (que es el receptor de la solicitud) rechazar una solicitud de amistad pendiente. Alternativamente, si el usuario autenticado fue quien envió la solicitud y esta aún está pendiente, puede usar este endpoint para cancelarla (aunque semánticamente esto último podría ser un endpoint diferente, la lógica actual del servicio elimina la solicitud PENDIENTE). La solicitud de amistad es eliminada de la base de datos. Requiere autenticación.
     * @summary Rechazar o cancelar una solicitud de amistad pendiente
     * @param {string} requesterUserPublicId ID público (UUID) del usuario que originalmente envió la solicitud de amistad que se desea rechazar/cancelar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    declineOrCancelFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Recupera una lista de todos los usuarios que son amigos del usuario actualmente autenticado (es decir, aquellas relaciones con estado \'ACCEPTED\'). Requiere autenticación.
     * @summary Obtener la lista de amigos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    getMyFriends(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>>;

    /**
     * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha recibido y aún están pendientes de acción (aceptar o rechazar). Requiere autenticación.
     * @summary Obtener las solicitudes de amistad pendientes recibidas por el usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    getPendingRequestsReceived(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>>;

    /**
     * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha enviado y que aún están pendientes de respuesta por parte de los destinatarios. Requiere autenticación.
     * @summary Obtener las solicitudes de amistad pendientes enviadas por el usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    getPendingRequestsSent(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendshipResponseDTO>>;

    /**
     * Permite al usuario autenticado eliminar una amistad existente con otro usuario, especificado por su ID público. La relación de amistad es eliminada de la base de datos. Requiere autenticación.
     * @summary Eliminar un amigo
     * @param {string} friendUserPublicId ID público (UUID) del amigo que se desea eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    removeFriend(friendUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Permite al usuario autenticado enviar una solicitud de amistad a otro usuario especificado por su ID público. Si ya existe una solicitud pendiente del receptor hacia el emisor, la amistad se aceptará automáticamente. Requiere autenticación.
     * @summary Enviar una solicitud de amistad
     * @param {string} receiverUserPublicId ID público (UUID) del usuario al que se le envía la solicitud de amistad.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApiInterface
     */
    sendFriendRequest(receiverUserPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipResponseDTO>;

}

/**
 * FriendshipControllerApi - object-oriented interface
 * @export
 * @class FriendshipControllerApi
 * @extends {BaseAPI}
 */
export class FriendshipControllerApi extends BaseAPI implements FriendshipControllerApiInterface {
    /**
     * Permite al usuario autenticado (que es el receptor de la solicitud) aceptar una solicitud de amistad pendiente de otro usuario. La solicitud debe estar en estado PENDIENTE. Requiere autenticación.
     * @summary Aceptar una solicitud de amistad pendiente
     * @param {string} requesterUserPublicId ID público (UUID) del usuario que envió la solicitud de amistad.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public acceptFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).acceptFriendRequest(requesterUserPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado (que es el receptor de la solicitud) rechazar una solicitud de amistad pendiente. Alternativamente, si el usuario autenticado fue quien envió la solicitud y esta aún está pendiente, puede usar este endpoint para cancelarla (aunque semánticamente esto último podría ser un endpoint diferente, la lógica actual del servicio elimina la solicitud PENDIENTE). La solicitud de amistad es eliminada de la base de datos. Requiere autenticación.
     * @summary Rechazar o cancelar una solicitud de amistad pendiente
     * @param {string} requesterUserPublicId ID público (UUID) del usuario que originalmente envió la solicitud de amistad que se desea rechazar/cancelar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public declineOrCancelFriendRequest(requesterUserPublicId: string, options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).declineOrCancelFriendRequest(requesterUserPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todos los usuarios que son amigos del usuario actualmente autenticado (es decir, aquellas relaciones con estado \'ACCEPTED\'). Requiere autenticación.
     * @summary Obtener la lista de amigos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public getMyFriends(options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).getMyFriends(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha recibido y aún están pendientes de acción (aceptar o rechazar). Requiere autenticación.
     * @summary Obtener las solicitudes de amistad pendientes recibidas por el usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public getPendingRequestsReceived(options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).getPendingRequestsReceived(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las solicitudes de amistad que el usuario actualmente autenticado ha enviado y que aún están pendientes de respuesta por parte de los destinatarios. Requiere autenticación.
     * @summary Obtener las solicitudes de amistad pendientes enviadas por el usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public getPendingRequestsSent(options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).getPendingRequestsSent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado eliminar una amistad existente con otro usuario, especificado por su ID público. La relación de amistad es eliminada de la base de datos. Requiere autenticación.
     * @summary Eliminar un amigo
     * @param {string} friendUserPublicId ID público (UUID) del amigo que se desea eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public removeFriend(friendUserPublicId: string, options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).removeFriend(friendUserPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado enviar una solicitud de amistad a otro usuario especificado por su ID público. Si ya existe una solicitud pendiente del receptor hacia el emisor, la amistad se aceptará automáticamente. Requiere autenticación.
     * @summary Enviar una solicitud de amistad
     * @param {string} receiverUserPublicId ID público (UUID) del usuario al que se le envía la solicitud de amistad.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendshipControllerApi
     */
    public sendFriendRequest(receiverUserPublicId: string, options?: RawAxiosRequestConfig) {
        return FriendshipControllerApiFp(this.configuration).sendFriendRequest(receiverUserPublicId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameControllerApi - axios parameter creator
 * @export
 */
export const GameControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Realiza una búsqueda de juegos en la base de datos de IGDB utilizando un término de búsqueda para el nombre. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos (nombre, calificación, carátula, fecha de lanzamiento, tipo, resumen, ID). Este endpoint es público.
         * @summary Buscar juegos en IGDB por nombre
         * @param {string} nombre Término de búsqueda para el nombre del juego.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarJuegosEnIgdb: async (nombre: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nombre' is not null or undefined
            assertParamExists('buscarJuegosEnIgdb', 'nombre', nombre)
            const localVarPath = `/api/juegos/igdb/buscar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (nombre !== undefined) {
                localVarQueryParameter['nombre'] = nombre;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite buscar juegos en IGDB aplicando filtros opcionales como rango de fechas de lanzamiento, ID de género, ID de tema, y ID de modo de juego. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos. Este endpoint es público.
         * @summary Filtrar juegos en IGDB por múltiples criterios
         * @param {number} [fechaInicio] Fecha de inicio del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [fechaFin] Fecha de fin del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [idGenero] ID del género según IGDB para filtrar. Opcional.
         * @param {number} [idTema] ID del tema según IGDB para filtrar. Opcional.
         * @param {number} [idModoJuego] ID del modo de juego según IGDB para filtrar. Opcional.
         * @param {number} [limite] Número máximo de resultados a devolver. Opcional. El valor por defecto se gestiona en el servidor (ej. 20), máximo 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtrarJuegosEnIgdb: async (fechaInicio?: number, fechaFin?: number, idGenero?: number, idTema?: number, idModoJuego?: number, limite?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/filtrar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fechaInicio !== undefined) {
                localVarQueryParameter['fecha_inicio'] = fechaInicio;
            }

            if (fechaFin !== undefined) {
                localVarQueryParameter['fecha_fin'] = fechaFin;
            }

            if (idGenero !== undefined) {
                localVarQueryParameter['id_genero'] = idGenero;
            }

            if (idTema !== undefined) {
                localVarQueryParameter['id_tema'] = idTema;
            }

            if (idModoJuego !== undefined) {
                localVarQueryParameter['id_modo_juego'] = idModoJuego;
            }

            if (limite !== undefined) {
                localVarQueryParameter['limite'] = limite;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todos los modos de juego disponibles en IGDB.
         * @summary Obtener todos los modos de juego de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllGameModes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/game-modes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todos los géneros de juegos disponibles en IGDB.
         * @summary Obtener todos los géneros de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllGenres: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todos los temas de juegos disponibles en IGDB.
         * @summary Obtener todos los temas de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllThemes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/themes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos más esperados, filtrados por su \'hype\'.
         * @summary Obtener los próximos lanzamientos más esperados desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHighlyAnticipatedGames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/highly-anticipated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de los 10 juegos más populares basados en su \'hype\' y un número significativo de calificaciones.
         * @summary Obtener los juegos más populares (hyped) desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMostHypedGames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/most-hyped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de los 10 juegos lanzados en los últimos 30 días, ordenados por fecha de lanzamiento descendente.
         * @summary Obtener juegos lanzados recientemente desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentlyReleasedGames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/recently-released`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos, ordenados por fecha de lanzamiento ascendente.
         * @summary Obtener los próximos lanzamientos desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUpcomingReleases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/juegos/igdb/upcoming-releases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameControllerApi - functional programming interface
 * @export
 */
export const GameControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Realiza una búsqueda de juegos en la base de datos de IGDB utilizando un término de búsqueda para el nombre. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos (nombre, calificación, carátula, fecha de lanzamiento, tipo, resumen, ID). Este endpoint es público.
         * @summary Buscar juegos en IGDB por nombre
         * @param {string} nombre Término de búsqueda para el nombre del juego.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buscarJuegosEnIgdb(nombre: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buscarJuegosEnIgdb(nombre, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.buscarJuegosEnIgdb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite buscar juegos en IGDB aplicando filtros opcionales como rango de fechas de lanzamiento, ID de género, ID de tema, y ID de modo de juego. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos. Este endpoint es público.
         * @summary Filtrar juegos en IGDB por múltiples criterios
         * @param {number} [fechaInicio] Fecha de inicio del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [fechaFin] Fecha de fin del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [idGenero] ID del género según IGDB para filtrar. Opcional.
         * @param {number} [idTema] ID del tema según IGDB para filtrar. Opcional.
         * @param {number} [idModoJuego] ID del modo de juego según IGDB para filtrar. Opcional.
         * @param {number} [limite] Número máximo de resultados a devolver. Opcional. El valor por defecto se gestiona en el servidor (ej. 20), máximo 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filtrarJuegosEnIgdb(fechaInicio?: number, fechaFin?: number, idGenero?: number, idTema?: number, idModoJuego?: number, limite?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filtrarJuegosEnIgdb(fechaInicio, fechaFin, idGenero, idTema, idModoJuego, limite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.filtrarJuegosEnIgdb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todos los modos de juego disponibles en IGDB.
         * @summary Obtener todos los modos de juego de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllGameModes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameModeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllGameModes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findAllGameModes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todos los géneros de juegos disponibles en IGDB.
         * @summary Obtener todos los géneros de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllGenres(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GenreDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllGenres(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findAllGenres']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todos los temas de juegos disponibles en IGDB.
         * @summary Obtener todos los temas de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllThemes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThemeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllThemes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findAllThemes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos más esperados, filtrados por su \'hype\'.
         * @summary Obtener los próximos lanzamientos más esperados desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findHighlyAnticipatedGames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findHighlyAnticipatedGames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findHighlyAnticipatedGames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de los 10 juegos más populares basados en su \'hype\' y un número significativo de calificaciones.
         * @summary Obtener los juegos más populares (hyped) desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMostHypedGames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMostHypedGames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findMostHypedGames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de los 10 juegos lanzados en los últimos 30 días, ordenados por fecha de lanzamiento descendente.
         * @summary Obtener juegos lanzados recientemente desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRecentlyReleasedGames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRecentlyReleasedGames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findRecentlyReleasedGames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos, ordenados por fecha de lanzamiento ascendente.
         * @summary Obtener los próximos lanzamientos desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUpcomingReleases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUpcomingReleases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameControllerApi.findUpcomingReleases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameControllerApi - factory interface
 * @export
 */
export const GameControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameControllerApiFp(configuration)
    return {
        /**
         * Realiza una búsqueda de juegos en la base de datos de IGDB utilizando un término de búsqueda para el nombre. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos (nombre, calificación, carátula, fecha de lanzamiento, tipo, resumen, ID). Este endpoint es público.
         * @summary Buscar juegos en IGDB por nombre
         * @param {string} nombre Término de búsqueda para el nombre del juego.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buscarJuegosEnIgdb(nombre: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.buscarJuegosEnIgdb(nombre, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite buscar juegos en IGDB aplicando filtros opcionales como rango de fechas de lanzamiento, ID de género, ID de tema, y ID de modo de juego. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos. Este endpoint es público.
         * @summary Filtrar juegos en IGDB por múltiples criterios
         * @param {number} [fechaInicio] Fecha de inicio del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [fechaFin] Fecha de fin del rango de lanzamiento (timestamp Unix en segundos). Opcional.
         * @param {number} [idGenero] ID del género según IGDB para filtrar. Opcional.
         * @param {number} [idTema] ID del tema según IGDB para filtrar. Opcional.
         * @param {number} [idModoJuego] ID del modo de juego según IGDB para filtrar. Opcional.
         * @param {number} [limite] Número máximo de resultados a devolver. Opcional. El valor por defecto se gestiona en el servidor (ej. 20), máximo 500.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filtrarJuegosEnIgdb(fechaInicio?: number, fechaFin?: number, idGenero?: number, idTema?: number, idModoJuego?: number, limite?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.filtrarJuegosEnIgdb(fechaInicio, fechaFin, idGenero, idTema, idModoJuego, limite, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todos los modos de juego disponibles en IGDB.
         * @summary Obtener todos los modos de juego de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllGameModes(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameModeDto>> {
            return localVarFp.findAllGameModes(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todos los géneros de juegos disponibles en IGDB.
         * @summary Obtener todos los géneros de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<GenreDto>> {
            return localVarFp.findAllGenres(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todos los temas de juegos disponibles en IGDB.
         * @summary Obtener todos los temas de IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllThemes(options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeDto>> {
            return localVarFp.findAllThemes(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos más esperados, filtrados por su \'hype\'.
         * @summary Obtener los próximos lanzamientos más esperados desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHighlyAnticipatedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.findHighlyAnticipatedGames(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de los 10 juegos más populares basados en su \'hype\' y un número significativo de calificaciones.
         * @summary Obtener los juegos más populares (hyped) desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMostHypedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.findMostHypedGames(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de los 10 juegos lanzados en los últimos 30 días, ordenados por fecha de lanzamiento descendente.
         * @summary Obtener juegos lanzados recientemente desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentlyReleasedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.findRecentlyReleasedGames(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de los 10 próximos lanzamientos, ordenados por fecha de lanzamiento ascendente.
         * @summary Obtener los próximos lanzamientos desde IGDB
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUpcomingReleases(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>> {
            return localVarFp.findUpcomingReleases(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameControllerApi - interface
 * @export
 * @interface GameControllerApi
 */
export interface GameControllerApiInterface {
    /**
     * Realiza una búsqueda de juegos en la base de datos de IGDB utilizando un término de búsqueda para el nombre. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos (nombre, calificación, carátula, fecha de lanzamiento, tipo, resumen, ID). Este endpoint es público.
     * @summary Buscar juegos en IGDB por nombre
     * @param {string} nombre Término de búsqueda para el nombre del juego.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    buscarJuegosEnIgdb(nombre: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

    /**
     * Permite buscar juegos en IGDB aplicando filtros opcionales como rango de fechas de lanzamiento, ID de género, ID de tema, y ID de modo de juego. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos. Este endpoint es público.
     * @summary Filtrar juegos en IGDB por múltiples criterios
     * @param {number} [fechaInicio] Fecha de inicio del rango de lanzamiento (timestamp Unix en segundos). Opcional.
     * @param {number} [fechaFin] Fecha de fin del rango de lanzamiento (timestamp Unix en segundos). Opcional.
     * @param {number} [idGenero] ID del género según IGDB para filtrar. Opcional.
     * @param {number} [idTema] ID del tema según IGDB para filtrar. Opcional.
     * @param {number} [idModoJuego] ID del modo de juego según IGDB para filtrar. Opcional.
     * @param {number} [limite] Número máximo de resultados a devolver. Opcional. El valor por defecto se gestiona en el servidor (ej. 20), máximo 500.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    filtrarJuegosEnIgdb(fechaInicio?: number, fechaFin?: number, idGenero?: number, idTema?: number, idModoJuego?: number, limite?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

    /**
     * Recupera una lista de todos los modos de juego disponibles en IGDB.
     * @summary Obtener todos los modos de juego de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findAllGameModes(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameModeDto>>;

    /**
     * Recupera una lista de todos los géneros de juegos disponibles en IGDB.
     * @summary Obtener todos los géneros de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findAllGenres(options?: RawAxiosRequestConfig): AxiosPromise<Array<GenreDto>>;

    /**
     * Recupera una lista de todos los temas de juegos disponibles en IGDB.
     * @summary Obtener todos los temas de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findAllThemes(options?: RawAxiosRequestConfig): AxiosPromise<Array<ThemeDto>>;

    /**
     * Recupera una lista de los 10 próximos lanzamientos más esperados, filtrados por su \'hype\'.
     * @summary Obtener los próximos lanzamientos más esperados desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findHighlyAnticipatedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

    /**
     * Recupera una lista de los 10 juegos más populares basados en su \'hype\' y un número significativo de calificaciones.
     * @summary Obtener los juegos más populares (hyped) desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findMostHypedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

    /**
     * Recupera una lista de los 10 juegos lanzados en los últimos 30 días, ordenados por fecha de lanzamiento descendente.
     * @summary Obtener juegos lanzados recientemente desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findRecentlyReleasedGames(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

    /**
     * Recupera una lista de los 10 próximos lanzamientos, ordenados por fecha de lanzamiento ascendente.
     * @summary Obtener los próximos lanzamientos desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApiInterface
     */
    findUpcomingReleases(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameDto>>;

}

/**
 * GameControllerApi - object-oriented interface
 * @export
 * @class GameControllerApi
 * @extends {BaseAPI}
 */
export class GameControllerApi extends BaseAPI implements GameControllerApiInterface {
    /**
     * Realiza una búsqueda de juegos en la base de datos de IGDB utilizando un término de búsqueda para el nombre. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos (nombre, calificación, carátula, fecha de lanzamiento, tipo, resumen, ID). Este endpoint es público.
     * @summary Buscar juegos en IGDB por nombre
     * @param {string} nombre Término de búsqueda para el nombre del juego.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public buscarJuegosEnIgdb(nombre: string, options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).buscarJuegosEnIgdb(nombre, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite buscar juegos en IGDB aplicando filtros opcionales como rango de fechas de lanzamiento, ID de género, ID de tema, y ID de modo de juego. Devuelve un flujo (o lista) de juegos que coinciden, con un conjunto limitado de campos. Este endpoint es público.
     * @summary Filtrar juegos en IGDB por múltiples criterios
     * @param {number} [fechaInicio] Fecha de inicio del rango de lanzamiento (timestamp Unix en segundos). Opcional.
     * @param {number} [fechaFin] Fecha de fin del rango de lanzamiento (timestamp Unix en segundos). Opcional.
     * @param {number} [idGenero] ID del género según IGDB para filtrar. Opcional.
     * @param {number} [idTema] ID del tema según IGDB para filtrar. Opcional.
     * @param {number} [idModoJuego] ID del modo de juego según IGDB para filtrar. Opcional.
     * @param {number} [limite] Número máximo de resultados a devolver. Opcional. El valor por defecto se gestiona en el servidor (ej. 20), máximo 500.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public filtrarJuegosEnIgdb(fechaInicio?: number, fechaFin?: number, idGenero?: number, idTema?: number, idModoJuego?: number, limite?: number, options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).filtrarJuegosEnIgdb(fechaInicio, fechaFin, idGenero, idTema, idModoJuego, limite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todos los modos de juego disponibles en IGDB.
     * @summary Obtener todos los modos de juego de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findAllGameModes(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findAllGameModes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todos los géneros de juegos disponibles en IGDB.
     * @summary Obtener todos los géneros de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findAllGenres(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findAllGenres(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todos los temas de juegos disponibles en IGDB.
     * @summary Obtener todos los temas de IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findAllThemes(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findAllThemes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de los 10 próximos lanzamientos más esperados, filtrados por su \'hype\'.
     * @summary Obtener los próximos lanzamientos más esperados desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findHighlyAnticipatedGames(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findHighlyAnticipatedGames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de los 10 juegos más populares basados en su \'hype\' y un número significativo de calificaciones.
     * @summary Obtener los juegos más populares (hyped) desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findMostHypedGames(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findMostHypedGames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de los 10 juegos lanzados en los últimos 30 días, ordenados por fecha de lanzamiento descendente.
     * @summary Obtener juegos lanzados recientemente desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findRecentlyReleasedGames(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findRecentlyReleasedGames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de los 10 próximos lanzamientos, ordenados por fecha de lanzamiento ascendente.
     * @summary Obtener los próximos lanzamientos desde IGDB
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public findUpcomingReleases(options?: RawAxiosRequestConfig) {
        return GameControllerApiFp(this.configuration).findUpcomingReleases(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameListControllerApi - axios parameter creator
 * @export
 */
export const GameListControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite al usuario autenticado añadir una entrada de juego existente en su biblioteca personal (identificada por su `user_game_id` interno) a una de sus listas de juegos personalizadas (identificada por `listPublicId`). El juego no se añade si ya está presente en la lista. Requiere autenticación.
         * @summary Añadir un juego de la biblioteca del usuario a una de sus listas de juegos
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a la que se añadirá el juego.
         * @param {AddGameToCustomListRequestDTO} addGameToCustomListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGameToMyCustomList: async (listPublicId: string, addGameToCustomListRequestDTO: AddGameToCustomListRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('addGameToMyCustomList', 'listPublicId', listPublicId)
            // verify required parameter 'addGameToCustomListRequestDTO' is not null or undefined
            assertParamExists('addGameToMyCustomList', 'addGameToCustomListRequestDTO', addGameToCustomListRequestDTO)
            const localVarPath = `/api/v1/users/me/gamelists/{listPublicId}/games`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addGameToCustomListRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado crear una nueva lista de juegos personalizada. Se requiere un nombre para la lista y se puede especificar si es pública o privada. Requiere autenticación.
         * @summary Crear una nueva lista de juegos para el usuario autenticado
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMyGameList: async (gameListRequestDTO: GameListRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameListRequestDTO' is not null or undefined
            assertParamExists('createMyGameList', 'gameListRequestDTO', gameListRequestDTO)
            const localVarPath = `/api/v1/users/me/gamelists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameListRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado eliminar una de sus listas de juegos existentes, identificada por su ID público (UUID). Esto no elimina los juegos de la biblioteca del usuario, solo la lista en sí. Requiere autenticación.
         * @summary Eliminar una lista de juegos del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyGameList: async (listPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('deleteMyGameList', 'listPublicId', listPublicId)
            const localVarPath = `/api/v1/users/me/gamelists/{listPublicId}`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las listas de juegos personalizadas creadas por el usuario actualmente autenticado. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Requiere autenticación.
         * @summary Obtener todas las listas de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGameLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/gamelists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica, identificada por su ID público (UUID), que pertenezca al usuario actualmente autenticado. Requiere autenticación.
         * @summary Obtener una lista de juegos específica del usuario autenticado por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySpecificGameList: async (listPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('getMySpecificGameList', 'listPublicId', listPublicId)
            const localVarPath = `/api/v1/users/me/gamelists/{listPublicId}`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su `userGameInternalId`) de una de sus listas de juegos (identificada por `listPublicId`). Esto no elimina el juego de la biblioteca general del usuario, solo de esta lista en particular. Requiere autenticación.
         * @summary Eliminar un juego de una lista de juegos personalizada del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos de la cual se eliminará el juego.
         * @param {number} userGameInternalId ID interno de la entrada \&#39;UserGame\&#39; (juego en la biblioteca del usuario) a eliminar de la lista.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGameFromMyCustomList: async (listPublicId: string, userGameInternalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('removeGameFromMyCustomList', 'listPublicId', listPublicId)
            // verify required parameter 'userGameInternalId' is not null or undefined
            assertParamExists('removeGameFromMyCustomList', 'userGameInternalId', userGameInternalId)
            const localVarPath = `/api/v1/users/me/gamelists/{listPublicId}/games/{userGameInternalId}`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)))
                .replace(`{${"userGameInternalId"}}`, encodeURIComponent(String(userGameInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado modificar los detalles (nombre, descripción, visibilidad) de una de sus listas de juegos existentes, identificada por su ID público (UUID). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación.
         * @summary Actualizar una lista de juegos existente del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a actualizar.
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGameList: async (listPublicId: string, gameListRequestDTO: GameListRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('updateMyGameList', 'listPublicId', listPublicId)
            // verify required parameter 'gameListRequestDTO' is not null or undefined
            assertParamExists('updateMyGameList', 'gameListRequestDTO', gameListRequestDTO)
            const localVarPath = `/api/v1/users/me/gamelists/{listPublicId}`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameListRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las listas de juegos que han sido marcadas como públicas por sus creadores. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las listas de juegos públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAllPublicGameLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/gamelists/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica que haya sido marcada como pública, identificada por su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener una lista de juegos pública específica por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos pública a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPublicGameList: async (listPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPublicId' is not null or undefined
            assertParamExists('viewPublicGameList', 'listPublicId', listPublicId)
            const localVarPath = `/api/v1/gamelists/{listPublicId}/public`
                .replace(`{${"listPublicId"}}`, encodeURIComponent(String(listPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameListControllerApi - functional programming interface
 * @export
 */
export const GameListControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameListControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite al usuario autenticado añadir una entrada de juego existente en su biblioteca personal (identificada por su `user_game_id` interno) a una de sus listas de juegos personalizadas (identificada por `listPublicId`). El juego no se añade si ya está presente en la lista. Requiere autenticación.
         * @summary Añadir un juego de la biblioteca del usuario a una de sus listas de juegos
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a la que se añadirá el juego.
         * @param {AddGameToCustomListRequestDTO} addGameToCustomListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGameToMyCustomList(listPublicId: string, addGameToCustomListRequestDTO: AddGameToCustomListRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGameToMyCustomList(listPublicId, addGameToCustomListRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.addGameToMyCustomList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado crear una nueva lista de juegos personalizada. Se requiere un nombre para la lista y se puede especificar si es pública o privada. Requiere autenticación.
         * @summary Crear una nueva lista de juegos para el usuario autenticado
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMyGameList(gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMyGameList(gameListRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.createMyGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado eliminar una de sus listas de juegos existentes, identificada por su ID público (UUID). Esto no elimina los juegos de la biblioteca del usuario, solo la lista en sí. Requiere autenticación.
         * @summary Eliminar una lista de juegos del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMyGameList(listPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMyGameList(listPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.deleteMyGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las listas de juegos personalizadas creadas por el usuario actualmente autenticado. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Requiere autenticación.
         * @summary Obtener todas las listas de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGameLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameListResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGameLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.getMyGameLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica, identificada por su ID público (UUID), que pertenezca al usuario actualmente autenticado. Requiere autenticación.
         * @summary Obtener una lista de juegos específica del usuario autenticado por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySpecificGameList(listPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySpecificGameList(listPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.getMySpecificGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su `userGameInternalId`) de una de sus listas de juegos (identificada por `listPublicId`). Esto no elimina el juego de la biblioteca general del usuario, solo de esta lista en particular. Requiere autenticación.
         * @summary Eliminar un juego de una lista de juegos personalizada del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos de la cual se eliminará el juego.
         * @param {number} userGameInternalId ID interno de la entrada \&#39;UserGame\&#39; (juego en la biblioteca del usuario) a eliminar de la lista.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeGameFromMyCustomList(listPublicId: string, userGameInternalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeGameFromMyCustomList(listPublicId, userGameInternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.removeGameFromMyCustomList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado modificar los detalles (nombre, descripción, visibilidad) de una de sus listas de juegos existentes, identificada por su ID público (UUID). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación.
         * @summary Actualizar una lista de juegos existente del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a actualizar.
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyGameList(listPublicId: string, gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyGameList(listPublicId, gameListRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.updateMyGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las listas de juegos que han sido marcadas como públicas por sus creadores. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las listas de juegos públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewAllPublicGameLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GameListResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewAllPublicGameLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.viewAllPublicGameLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica que haya sido marcada como pública, identificada por su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener una lista de juegos pública específica por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos pública a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewPublicGameList(listPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewPublicGameList(listPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameListControllerApi.viewPublicGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameListControllerApi - factory interface
 * @export
 */
export const GameListControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameListControllerApiFp(configuration)
    return {
        /**
         * Permite al usuario autenticado añadir una entrada de juego existente en su biblioteca personal (identificada por su `user_game_id` interno) a una de sus listas de juegos personalizadas (identificada por `listPublicId`). El juego no se añade si ya está presente en la lista. Requiere autenticación.
         * @summary Añadir un juego de la biblioteca del usuario a una de sus listas de juegos
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a la que se añadirá el juego.
         * @param {AddGameToCustomListRequestDTO} addGameToCustomListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGameToMyCustomList(listPublicId: string, addGameToCustomListRequestDTO: AddGameToCustomListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO> {
            return localVarFp.addGameToMyCustomList(listPublicId, addGameToCustomListRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado crear una nueva lista de juegos personalizada. Se requiere un nombre para la lista y se puede especificar si es pública o privada. Requiere autenticación.
         * @summary Crear una nueva lista de juegos para el usuario autenticado
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMyGameList(gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO> {
            return localVarFp.createMyGameList(gameListRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado eliminar una de sus listas de juegos existentes, identificada por su ID público (UUID). Esto no elimina los juegos de la biblioteca del usuario, solo la lista en sí. Requiere autenticación.
         * @summary Eliminar una lista de juegos del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMyGameList(listPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las listas de juegos personalizadas creadas por el usuario actualmente autenticado. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Requiere autenticación.
         * @summary Obtener todas las listas de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGameLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameListResponseDTO>> {
            return localVarFp.getMyGameLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica, identificada por su ID público (UUID), que pertenezca al usuario actualmente autenticado. Requiere autenticación.
         * @summary Obtener una lista de juegos específica del usuario autenticado por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySpecificGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO> {
            return localVarFp.getMySpecificGameList(listPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su `userGameInternalId`) de una de sus listas de juegos (identificada por `listPublicId`). Esto no elimina el juego de la biblioteca general del usuario, solo de esta lista en particular. Requiere autenticación.
         * @summary Eliminar un juego de una lista de juegos personalizada del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos de la cual se eliminará el juego.
         * @param {number} userGameInternalId ID interno de la entrada \&#39;UserGame\&#39; (juego en la biblioteca del usuario) a eliminar de la lista.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGameFromMyCustomList(listPublicId: string, userGameInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeGameFromMyCustomList(listPublicId, userGameInternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado modificar los detalles (nombre, descripción, visibilidad) de una de sus listas de juegos existentes, identificada por su ID público (UUID). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación.
         * @summary Actualizar una lista de juegos existente del usuario autenticado
         * @param {string} listPublicId ID público (UUID) de la lista de juegos a actualizar.
         * @param {GameListRequestDTO} gameListRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyGameList(listPublicId: string, gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO> {
            return localVarFp.updateMyGameList(listPublicId, gameListRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las listas de juegos que han sido marcadas como públicas por sus creadores. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las listas de juegos públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewAllPublicGameLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameListResponseDTO>> {
            return localVarFp.viewAllPublicGameLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles y los juegos contenidos en una lista de juegos específica que haya sido marcada como pública, identificada por su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener una lista de juegos pública específica por su ID público
         * @param {string} listPublicId ID público (UUID) de la lista de juegos pública a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPublicGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO> {
            return localVarFp.viewPublicGameList(listPublicId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameListControllerApi - interface
 * @export
 * @interface GameListControllerApi
 */
export interface GameListControllerApiInterface {
    /**
     * Permite al usuario autenticado añadir una entrada de juego existente en su biblioteca personal (identificada por su `user_game_id` interno) a una de sus listas de juegos personalizadas (identificada por `listPublicId`). El juego no se añade si ya está presente en la lista. Requiere autenticación.
     * @summary Añadir un juego de la biblioteca del usuario a una de sus listas de juegos
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a la que se añadirá el juego.
     * @param {AddGameToCustomListRequestDTO} addGameToCustomListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    addGameToMyCustomList(listPublicId: string, addGameToCustomListRequestDTO: AddGameToCustomListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO>;

    /**
     * Permite al usuario autenticado crear una nueva lista de juegos personalizada. Se requiere un nombre para la lista y se puede especificar si es pública o privada. Requiere autenticación.
     * @summary Crear una nueva lista de juegos para el usuario autenticado
     * @param {GameListRequestDTO} gameListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    createMyGameList(gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO>;

    /**
     * Permite al usuario autenticado eliminar una de sus listas de juegos existentes, identificada por su ID público (UUID). Esto no elimina los juegos de la biblioteca del usuario, solo la lista en sí. Requiere autenticación.
     * @summary Eliminar una lista de juegos del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    deleteMyGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Recupera una lista de todas las listas de juegos personalizadas creadas por el usuario actualmente autenticado. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Requiere autenticación.
     * @summary Obtener todas las listas de juegos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    getMyGameLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameListResponseDTO>>;

    /**
     * Recupera los detalles y los juegos contenidos en una lista de juegos específica, identificada por su ID público (UUID), que pertenezca al usuario actualmente autenticado. Requiere autenticación.
     * @summary Obtener una lista de juegos específica del usuario autenticado por su ID público
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    getMySpecificGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO>;

    /**
     * Permite al usuario autenticado eliminar un juego específico (identificado por su `userGameInternalId`) de una de sus listas de juegos (identificada por `listPublicId`). Esto no elimina el juego de la biblioteca general del usuario, solo de esta lista en particular. Requiere autenticación.
     * @summary Eliminar un juego de una lista de juegos personalizada del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos de la cual se eliminará el juego.
     * @param {number} userGameInternalId ID interno de la entrada \&#39;UserGame\&#39; (juego en la biblioteca del usuario) a eliminar de la lista.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    removeGameFromMyCustomList(listPublicId: string, userGameInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Permite al usuario autenticado modificar los detalles (nombre, descripción, visibilidad) de una de sus listas de juegos existentes, identificada por su ID público (UUID). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación.
     * @summary Actualizar una lista de juegos existente del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a actualizar.
     * @param {GameListRequestDTO} gameListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    updateMyGameList(listPublicId: string, gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO>;

    /**
     * Recupera una lista de todas las listas de juegos que han sido marcadas como públicas por sus creadores. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Este endpoint es público y no requiere autenticación.
     * @summary Obtener todas las listas de juegos públicas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    viewAllPublicGameLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<GameListResponseDTO>>;

    /**
     * Recupera los detalles y los juegos contenidos en una lista de juegos específica que haya sido marcada como pública, identificada por su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener una lista de juegos pública específica por su ID público
     * @param {string} listPublicId ID público (UUID) de la lista de juegos pública a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApiInterface
     */
    viewPublicGameList(listPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<GameListResponseDTO>;

}

/**
 * GameListControllerApi - object-oriented interface
 * @export
 * @class GameListControllerApi
 * @extends {BaseAPI}
 */
export class GameListControllerApi extends BaseAPI implements GameListControllerApiInterface {
    /**
     * Permite al usuario autenticado añadir una entrada de juego existente en su biblioteca personal (identificada por su `user_game_id` interno) a una de sus listas de juegos personalizadas (identificada por `listPublicId`). El juego no se añade si ya está presente en la lista. Requiere autenticación.
     * @summary Añadir un juego de la biblioteca del usuario a una de sus listas de juegos
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a la que se añadirá el juego.
     * @param {AddGameToCustomListRequestDTO} addGameToCustomListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public addGameToMyCustomList(listPublicId: string, addGameToCustomListRequestDTO: AddGameToCustomListRequestDTO, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).addGameToMyCustomList(listPublicId, addGameToCustomListRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado crear una nueva lista de juegos personalizada. Se requiere un nombre para la lista y se puede especificar si es pública o privada. Requiere autenticación.
     * @summary Crear una nueva lista de juegos para el usuario autenticado
     * @param {GameListRequestDTO} gameListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public createMyGameList(gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).createMyGameList(gameListRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado eliminar una de sus listas de juegos existentes, identificada por su ID público (UUID). Esto no elimina los juegos de la biblioteca del usuario, solo la lista en sí. Requiere autenticación.
     * @summary Eliminar una lista de juegos del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public deleteMyGameList(listPublicId: string, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).deleteMyGameList(listPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las listas de juegos personalizadas creadas por el usuario actualmente autenticado. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Requiere autenticación.
     * @summary Obtener todas las listas de juegos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public getMyGameLists(options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).getMyGameLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles y los juegos contenidos en una lista de juegos específica, identificada por su ID público (UUID), que pertenezca al usuario actualmente autenticado. Requiere autenticación.
     * @summary Obtener una lista de juegos específica del usuario autenticado por su ID público
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public getMySpecificGameList(listPublicId: string, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).getMySpecificGameList(listPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado eliminar un juego específico (identificado por su `userGameInternalId`) de una de sus listas de juegos (identificada por `listPublicId`). Esto no elimina el juego de la biblioteca general del usuario, solo de esta lista en particular. Requiere autenticación.
     * @summary Eliminar un juego de una lista de juegos personalizada del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos de la cual se eliminará el juego.
     * @param {number} userGameInternalId ID interno de la entrada \&#39;UserGame\&#39; (juego en la biblioteca del usuario) a eliminar de la lista.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public removeGameFromMyCustomList(listPublicId: string, userGameInternalId: number, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).removeGameFromMyCustomList(listPublicId, userGameInternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado modificar los detalles (nombre, descripción, visibilidad) de una de sus listas de juegos existentes, identificada por su ID público (UUID). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación.
     * @summary Actualizar una lista de juegos existente del usuario autenticado
     * @param {string} listPublicId ID público (UUID) de la lista de juegos a actualizar.
     * @param {GameListRequestDTO} gameListRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public updateMyGameList(listPublicId: string, gameListRequestDTO: GameListRequestDTO, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).updateMyGameList(listPublicId, gameListRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las listas de juegos que han sido marcadas como públicas por sus creadores. Las listas se devuelven ordenadas por la fecha de última actualización de forma descendente. Este endpoint es público y no requiere autenticación.
     * @summary Obtener todas las listas de juegos públicas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public viewAllPublicGameLists(options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).viewAllPublicGameLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles y los juegos contenidos en una lista de juegos específica que haya sido marcada como pública, identificada por su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener una lista de juegos pública específica por su ID público
     * @param {string} listPublicId ID público (UUID) de la lista de juegos pública a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameListControllerApi
     */
    public viewPublicGameList(listPublicId: string, options?: RawAxiosRequestConfig) {
        return GameListControllerApiFp(this.configuration).viewPublicGameList(listPublicId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TierListControllerApi - axios parameter creator
 * @export
 */
export const TierListControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) a una sección específica de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la nueva sección y posición. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\' ni para añadir a la sección \'Juegos por Clasificar\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a una sección específica de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) destino dentro de la Tier List.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToTierListSection: async (tierListPublicId: string, sectionInternalId: number, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('addItemToTierListSection', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'sectionInternalId' is not null or undefined
            assertParamExists('addItemToTierListSection', 'sectionInternalId', sectionInternalId)
            // verify required parameter 'tierListItemAddRequestDTO' is not null or undefined
            assertParamExists('addItemToTierListSection', 'tierListItemAddRequestDTO', tierListItemAddRequestDTO)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/sections/{sectionInternalId}/items`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)))
                .replace(`{${"sectionInternalId"}}`, encodeURIComponent(String(sectionInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierListItemAddRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) directamente a la sección \'Juegos por Clasificar\' de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la sección \'Juegos por Clasificar\'. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a la sección \'Sin Clasificar\' de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem en la sección \&#39;Sin Clasificar\&#39;.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUnclassifiedSection: async (tierListPublicId: string, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('addItemToUnclassifiedSection', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'tierListItemAddRequestDTO' is not null or undefined
            assertParamExists('addItemToUnclassifiedSection', 'tierListItemAddRequestDTO', tierListItemAddRequestDTO)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/items/unclassified`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierListItemAddRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado de una Tier List añadir una nueva sección personalizada. Existe un límite en la cantidad de secciones personalizables que se pueden añadir. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Añadir una nueva sección (tier) a una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá la nueva sección.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSectionToTierList: async (tierListPublicId: string, tierSectionRequestDTO: TierSectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('addSectionToTierList', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'tierSectionRequestDTO' is not null or undefined
            assertParamExists('addSectionToTierList', 'tierSectionRequestDTO', tierSectionRequestDTO)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/sections`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierSectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado crear una nueva Tier List de tipo \'PROFILE_GLOBAL\'. Se requiere un nombre para la lista y opcionalmente una descripción y si es pública. Se crearán secciones por defecto (S, A, B, C, D y \'Juegos por Clasificar\'). Requiere autenticación.
         * @summary Crear una nueva Tier List de perfil para el usuario autenticado
         * @param {TierListCreateRequestDTO} tierListCreateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileTierList: async (tierListCreateRequestDTO: TierListCreateRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListCreateRequestDTO' is not null or undefined
            assertParamExists('createProfileTierList', 'tierListCreateRequestDTO', tierListCreateRequestDTO)
            const localVarPath = `/api/v1/users/me/tierlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierListCreateRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminarla permanentemente. Esto también eliminará todas las secciones y los ítems contenidos en ella. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTierList: async (tierListPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('deleteTierList', 'tierListPublicId', tierListPublicId)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las Tier Lists de tipo \'PROFILE_GLOBAL\' creadas por el usuario actualmente autenticado. Cada Tier List incluye sus secciones y los ítems clasificados. Requiere autenticación.
         * @summary Obtener todas las Tier Lists de perfil del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProfileTierListsForCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/tierlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera una lista de todas las Tier Lists que han sido marcadas como públicas por sus creadores. Cada Tier List incluye sus secciones y los ítems clasificados. Las listas se devuelven ordenadas por la fecha de última actualización. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las Tier Lists públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicTierLists: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tierlists/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera la Tier List de tipo \'FROM_GAMELIST\' asociada a la GameList especificada por su ID público. Si no existe una Tier List para esa GameList, se crea una nueva automáticamente con secciones por defecto y se sincroniza con los juegos de la GameList (añadiéndolos a la sección \'Sin Clasificar\'). Este endpoint es público si la GameList y la TierList resultante son públicas. Si la GameList es privada, se requiere autenticación y ser el propietario para acceder o crear la TierList asociada. Si se proporciona un token JWT válido, la respuesta puede incluir información adicional si el usuario es el propietario.
         * @summary Obtener o crear la Tier List asociada a una GameList específica
         * @param {string} gameListPublicId ID público (UUID) de la GameList para la cual se obtendrá o creará la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateTierListForGameList: async (gameListPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameListPublicId' is not null or undefined
            assertParamExists('getOrCreateTierListForGameList', 'gameListPublicId', gameListPublicId)
            const localVarPath = `/api/v1/gamelists/{gameListPublicId}/tierlist`
                .replace(`{${"gameListPublicId"}}`, encodeURIComponent(String(gameListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles completos de una Tier List (incluyendo secciones e ítems) utilizando su ID público (UUID). Si la Tier List es pública, cualquiera puede acceder a ella. Si la Tier List es privada, solo el propietario autenticado puede acceder. La autenticación (JWT) es opcional; si se proporciona un token válido y la lista es privada, se verificará la propiedad.
         * @summary Obtener una Tier List específica por su ID público
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTierListByPublicId: async (tierListPublicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('getTierListByPublicId', 'tierListPublicId', tierListPublicId)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado mover un ítem existente (identificado por `tierListItemInternalId`) a una nueva sección (`target_section_internal_id`) y/o a una nueva posición (`new_order`) dentro de esa sección en una Tier List específica. Para Tier Lists de tipo \'FROM_GAMELIST\', se verifica que el juego del ítem aún pertenezca a la GameList origen. Requiere autenticación y ser propietario de la Tier List.
         * @summary Mover un ítem (juego) dentro de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene el ítem a mover.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a mover.
         * @param {TierListItemMoveRequestDTO} tierListItemMoveRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItemInTierList: async (tierListPublicId: string, tierListItemInternalId: number, tierListItemMoveRequestDTO: TierListItemMoveRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('moveItemInTierList', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'tierListItemInternalId' is not null or undefined
            assertParamExists('moveItemInTierList', 'tierListItemInternalId', tierListItemInternalId)
            // verify required parameter 'tierListItemMoveRequestDTO' is not null or undefined
            assertParamExists('moveItemInTierList', 'tierListItemMoveRequestDTO', tierListItemMoveRequestDTO)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/items/{tierListItemInternalId}/move`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)))
                .replace(`{${"tierListItemInternalId"}}`, encodeURIComponent(String(tierListItemInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierListItemMoveRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado eliminar un ítem específico (identificado por `tierListItemInternalId`) de una de sus Tier Lists de tipo \'PROFILE_GLOBAL\'. Esto no elimina el juego de la biblioteca general del usuario, solo de esta Tier List. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Requiere autenticación y ser propietario.
         * @summary Eliminar un ítem (juego) de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará el ítem.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a eliminar de la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromTierList: async (tierListPublicId: string, tierListItemInternalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('removeItemFromTierList', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'tierListItemInternalId' is not null or undefined
            assertParamExists('removeItemFromTierList', 'tierListItemInternalId', tierListItemInternalId)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/items/{tierListItemInternalId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)))
                .replace(`{${"tierListItemInternalId"}}`, encodeURIComponent(String(tierListItemInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminar una de sus secciones personalizadas. La sección por defecto \'Juegos por Clasificar\' no puede ser eliminada. Debe quedar al menos una sección personalizable tras la eliminación. Si la sección eliminada contenía ítems (juegos), estos serán movidos a la sección \'Juegos por Clasificar\'. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una sección (tier) de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará la sección.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSectionFromTierList: async (tierListPublicId: string, sectionInternalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('removeSectionFromTierList', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'sectionInternalId' is not null or undefined
            assertParamExists('removeSectionFromTierList', 'sectionInternalId', sectionInternalId)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}/sections/{sectionInternalId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)))
                .replace(`{${"sectionInternalId"}}`, encodeURIComponent(String(sectionInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado de una Tier List modificar sus metadatos como el nombre, la descripción y el estado de visibilidad (pública/privada). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar los metadatos de una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a actualizar.
         * @param {TierListUpdateRequestDTO} tierListUpdateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierListMetadata: async (tierListPublicId: string, tierListUpdateRequestDTO: TierListUpdateRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('updateTierListMetadata', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'tierListUpdateRequestDTO' is not null or undefined
            assertParamExists('updateTierListMetadata', 'tierListUpdateRequestDTO', tierListUpdateRequestDTO)
            const localVarPath = `/api/v1/tierlists/{tierListPublicId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierListUpdateRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al propietario autenticado de una Tier List cambiar las propiedades de una de sus secciones, como el nombre y el color. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar una sección (tier) específica de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene la sección a actualizar.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) cuyo nombre se va a actualizar.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierSection: async (tierListPublicId: string, sectionInternalId: number, tierSectionRequestDTO: TierSectionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tierListPublicId' is not null or undefined
            assertParamExists('updateTierSection', 'tierListPublicId', tierListPublicId)
            // verify required parameter 'sectionInternalId' is not null or undefined
            assertParamExists('updateTierSection', 'sectionInternalId', sectionInternalId)
            // verify required parameter 'tierSectionRequestDTO' is not null or undefined
            assertParamExists('updateTierSection', 'tierSectionRequestDTO', tierSectionRequestDTO)
            const localVarPath = `/api/v1/{tierListPublicId}/sections/{sectionInternalId}`
                .replace(`{${"tierListPublicId"}}`, encodeURIComponent(String(tierListPublicId)))
                .replace(`{${"sectionInternalId"}}`, encodeURIComponent(String(sectionInternalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tierSectionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TierListControllerApi - functional programming interface
 * @export
 */
export const TierListControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TierListControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) a una sección específica de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la nueva sección y posición. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\' ni para añadir a la sección \'Juegos por Clasificar\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a una sección específica de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) destino dentro de la Tier List.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItemToTierListSection(tierListPublicId: string, sectionInternalId: number, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addItemToTierListSection(tierListPublicId, sectionInternalId, tierListItemAddRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.addItemToTierListSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) directamente a la sección \'Juegos por Clasificar\' de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la sección \'Juegos por Clasificar\'. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a la sección \'Sin Clasificar\' de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem en la sección \&#39;Sin Clasificar\&#39;.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItemToUnclassifiedSection(tierListPublicId: string, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addItemToUnclassifiedSection(tierListPublicId, tierListItemAddRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.addItemToUnclassifiedSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado de una Tier List añadir una nueva sección personalizada. Existe un límite en la cantidad de secciones personalizables que se pueden añadir. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Añadir una nueva sección (tier) a una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá la nueva sección.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSectionToTierList(tierListPublicId: string, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSectionToTierList(tierListPublicId, tierSectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.addSectionToTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado crear una nueva Tier List de tipo \'PROFILE_GLOBAL\'. Se requiere un nombre para la lista y opcionalmente una descripción y si es pública. Se crearán secciones por defecto (S, A, B, C, D y \'Juegos por Clasificar\'). Requiere autenticación.
         * @summary Crear una nueva Tier List de perfil para el usuario autenticado
         * @param {TierListCreateRequestDTO} tierListCreateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileTierList(tierListCreateRequestDTO: TierListCreateRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileTierList(tierListCreateRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.createProfileTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminarla permanentemente. Esto también eliminará todas las secciones y los ítems contenidos en ella. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTierList(tierListPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTierList(tierListPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.deleteTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las Tier Lists de tipo \'PROFILE_GLOBAL\' creadas por el usuario actualmente autenticado. Cada Tier List incluye sus secciones y los ítems clasificados. Requiere autenticación.
         * @summary Obtener todas las Tier Lists de perfil del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProfileTierListsForCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TierListResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProfileTierListsForCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.getAllProfileTierListsForCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera una lista de todas las Tier Lists que han sido marcadas como públicas por sus creadores. Cada Tier List incluye sus secciones y los ítems clasificados. Las listas se devuelven ordenadas por la fecha de última actualización. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las Tier Lists públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPublicTierLists(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TierListResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPublicTierLists(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.getAllPublicTierLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera la Tier List de tipo \'FROM_GAMELIST\' asociada a la GameList especificada por su ID público. Si no existe una Tier List para esa GameList, se crea una nueva automáticamente con secciones por defecto y se sincroniza con los juegos de la GameList (añadiéndolos a la sección \'Sin Clasificar\'). Este endpoint es público si la GameList y la TierList resultante son públicas. Si la GameList es privada, se requiere autenticación y ser el propietario para acceder o crear la TierList asociada. Si se proporciona un token JWT válido, la respuesta puede incluir información adicional si el usuario es el propietario.
         * @summary Obtener o crear la Tier List asociada a una GameList específica
         * @param {string} gameListPublicId ID público (UUID) de la GameList para la cual se obtendrá o creará la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrCreateTierListForGameList(gameListPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateTierListForGameList(gameListPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.getOrCreateTierListForGameList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles completos de una Tier List (incluyendo secciones e ítems) utilizando su ID público (UUID). Si la Tier List es pública, cualquiera puede acceder a ella. Si la Tier List es privada, solo el propietario autenticado puede acceder. La autenticación (JWT) es opcional; si se proporciona un token válido y la lista es privada, se verificará la propiedad.
         * @summary Obtener una Tier List específica por su ID público
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTierListByPublicId(tierListPublicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTierListByPublicId(tierListPublicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.getTierListByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado mover un ítem existente (identificado por `tierListItemInternalId`) a una nueva sección (`target_section_internal_id`) y/o a una nueva posición (`new_order`) dentro de esa sección en una Tier List específica. Para Tier Lists de tipo \'FROM_GAMELIST\', se verifica que el juego del ítem aún pertenezca a la GameList origen. Requiere autenticación y ser propietario de la Tier List.
         * @summary Mover un ítem (juego) dentro de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene el ítem a mover.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a mover.
         * @param {TierListItemMoveRequestDTO} tierListItemMoveRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveItemInTierList(tierListPublicId: string, tierListItemInternalId: number, tierListItemMoveRequestDTO: TierListItemMoveRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveItemInTierList(tierListPublicId, tierListItemInternalId, tierListItemMoveRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.moveItemInTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado eliminar un ítem específico (identificado por `tierListItemInternalId`) de una de sus Tier Lists de tipo \'PROFILE_GLOBAL\'. Esto no elimina el juego de la biblioteca general del usuario, solo de esta Tier List. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Requiere autenticación y ser propietario.
         * @summary Eliminar un ítem (juego) de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará el ítem.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a eliminar de la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeItemFromTierList(tierListPublicId: string, tierListItemInternalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeItemFromTierList(tierListPublicId, tierListItemInternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.removeItemFromTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminar una de sus secciones personalizadas. La sección por defecto \'Juegos por Clasificar\' no puede ser eliminada. Debe quedar al menos una sección personalizable tras la eliminación. Si la sección eliminada contenía ítems (juegos), estos serán movidos a la sección \'Juegos por Clasificar\'. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una sección (tier) de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará la sección.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSectionFromTierList(tierListPublicId: string, sectionInternalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSectionFromTierList(tierListPublicId, sectionInternalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.removeSectionFromTierList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado de una Tier List modificar sus metadatos como el nombre, la descripción y el estado de visibilidad (pública/privada). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar los metadatos de una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a actualizar.
         * @param {TierListUpdateRequestDTO} tierListUpdateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTierListMetadata(tierListPublicId: string, tierListUpdateRequestDTO: TierListUpdateRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTierListMetadata(tierListPublicId, tierListUpdateRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.updateTierListMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al propietario autenticado de una Tier List cambiar las propiedades de una de sus secciones, como el nombre y el color. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar una sección (tier) específica de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene la sección a actualizar.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) cuyo nombre se va a actualizar.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTierSection(tierListPublicId: string, sectionInternalId: number, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TierListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTierSection(tierListPublicId, sectionInternalId, tierSectionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TierListControllerApi.updateTierSection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TierListControllerApi - factory interface
 * @export
 */
export const TierListControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TierListControllerApiFp(configuration)
    return {
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) a una sección específica de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la nueva sección y posición. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\' ni para añadir a la sección \'Juegos por Clasificar\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a una sección específica de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) destino dentro de la Tier List.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToTierListSection(tierListPublicId: string, sectionInternalId: number, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.addItemToTierListSection(tierListPublicId, sectionInternalId, tierListItemAddRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) directamente a la sección \'Juegos por Clasificar\' de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la sección \'Juegos por Clasificar\'. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
         * @summary Añadir o mover un ítem (juego) a la sección \'Sin Clasificar\' de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem en la sección \&#39;Sin Clasificar\&#39;.
         * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUnclassifiedSection(tierListPublicId: string, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.addItemToUnclassifiedSection(tierListPublicId, tierListItemAddRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado de una Tier List añadir una nueva sección personalizada. Existe un límite en la cantidad de secciones personalizables que se pueden añadir. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Añadir una nueva sección (tier) a una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá la nueva sección.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSectionToTierList(tierListPublicId: string, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.addSectionToTierList(tierListPublicId, tierSectionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado crear una nueva Tier List de tipo \'PROFILE_GLOBAL\'. Se requiere un nombre para la lista y opcionalmente una descripción y si es pública. Se crearán secciones por defecto (S, A, B, C, D y \'Juegos por Clasificar\'). Requiere autenticación.
         * @summary Crear una nueva Tier List de perfil para el usuario autenticado
         * @param {TierListCreateRequestDTO} tierListCreateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileTierList(tierListCreateRequestDTO: TierListCreateRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.createProfileTierList(tierListCreateRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminarla permanentemente. Esto también eliminará todas las secciones y los ítems contenidos en ella. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTierList(tierListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTierList(tierListPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las Tier Lists de tipo \'PROFILE_GLOBAL\' creadas por el usuario actualmente autenticado. Cada Tier List incluye sus secciones y los ítems clasificados. Requiere autenticación.
         * @summary Obtener todas las Tier Lists de perfil del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProfileTierListsForCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<Array<TierListResponseDTO>> {
            return localVarFp.getAllProfileTierListsForCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera una lista de todas las Tier Lists que han sido marcadas como públicas por sus creadores. Cada Tier List incluye sus secciones y los ítems clasificados. Las listas se devuelven ordenadas por la fecha de última actualización. Este endpoint es público y no requiere autenticación.
         * @summary Obtener todas las Tier Lists públicas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicTierLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<TierListResponseDTO>> {
            return localVarFp.getAllPublicTierLists(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera la Tier List de tipo \'FROM_GAMELIST\' asociada a la GameList especificada por su ID público. Si no existe una Tier List para esa GameList, se crea una nueva automáticamente con secciones por defecto y se sincroniza con los juegos de la GameList (añadiéndolos a la sección \'Sin Clasificar\'). Este endpoint es público si la GameList y la TierList resultante son públicas. Si la GameList es privada, se requiere autenticación y ser el propietario para acceder o crear la TierList asociada. Si se proporciona un token JWT válido, la respuesta puede incluir información adicional si el usuario es el propietario.
         * @summary Obtener o crear la Tier List asociada a una GameList específica
         * @param {string} gameListPublicId ID público (UUID) de la GameList para la cual se obtendrá o creará la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateTierListForGameList(gameListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.getOrCreateTierListForGameList(gameListPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles completos de una Tier List (incluyendo secciones e ítems) utilizando su ID público (UUID). Si la Tier List es pública, cualquiera puede acceder a ella. Si la Tier List es privada, solo el propietario autenticado puede acceder. La autenticación (JWT) es opcional; si se proporciona un token válido y la lista es privada, se verificará la propiedad.
         * @summary Obtener una Tier List específica por su ID público
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTierListByPublicId(tierListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.getTierListByPublicId(tierListPublicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado mover un ítem existente (identificado por `tierListItemInternalId`) a una nueva sección (`target_section_internal_id`) y/o a una nueva posición (`new_order`) dentro de esa sección en una Tier List específica. Para Tier Lists de tipo \'FROM_GAMELIST\', se verifica que el juego del ítem aún pertenezca a la GameList origen. Requiere autenticación y ser propietario de la Tier List.
         * @summary Mover un ítem (juego) dentro de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene el ítem a mover.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a mover.
         * @param {TierListItemMoveRequestDTO} tierListItemMoveRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItemInTierList(tierListPublicId: string, tierListItemInternalId: number, tierListItemMoveRequestDTO: TierListItemMoveRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.moveItemInTierList(tierListPublicId, tierListItemInternalId, tierListItemMoveRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado eliminar un ítem específico (identificado por `tierListItemInternalId`) de una de sus Tier Lists de tipo \'PROFILE_GLOBAL\'. Esto no elimina el juego de la biblioteca general del usuario, solo de esta Tier List. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Requiere autenticación y ser propietario.
         * @summary Eliminar un ítem (juego) de una Tier List de perfil
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará el ítem.
         * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a eliminar de la Tier List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromTierList(tierListPublicId: string, tierListItemInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.removeItemFromTierList(tierListPublicId, tierListItemInternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado de una Tier List eliminar una de sus secciones personalizadas. La sección por defecto \'Juegos por Clasificar\' no puede ser eliminada. Debe quedar al menos una sección personalizable tras la eliminación. Si la sección eliminada contenía ítems (juegos), estos serán movidos a la sección \'Juegos por Clasificar\'. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Eliminar una sección (tier) de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará la sección.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) a eliminar.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSectionFromTierList(tierListPublicId: string, sectionInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.removeSectionFromTierList(tierListPublicId, sectionInternalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado de una Tier List modificar sus metadatos como el nombre, la descripción y el estado de visibilidad (pública/privada). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar los metadatos de una Tier List existente
         * @param {string} tierListPublicId ID público (UUID) de la Tier List a actualizar.
         * @param {TierListUpdateRequestDTO} tierListUpdateRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierListMetadata(tierListPublicId: string, tierListUpdateRequestDTO: TierListUpdateRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.updateTierListMetadata(tierListPublicId, tierListUpdateRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al propietario autenticado de una Tier List cambiar las propiedades de una de sus secciones, como el nombre y el color. Requiere autenticación y ser el propietario de la Tier List.
         * @summary Actualizar una sección (tier) específica de una Tier List
         * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene la sección a actualizar.
         * @param {number} sectionInternalId ID interno (Long) de la sección (tier) cuyo nombre se va a actualizar.
         * @param {TierSectionRequestDTO} tierSectionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTierSection(tierListPublicId: string, sectionInternalId: number, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO> {
            return localVarFp.updateTierSection(tierListPublicId, sectionInternalId, tierSectionRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TierListControllerApi - interface
 * @export
 * @interface TierListControllerApi
 */
export interface TierListControllerApiInterface {
    /**
     * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) a una sección específica de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la nueva sección y posición. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\' ni para añadir a la sección \'Juegos por Clasificar\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
     * @summary Añadir o mover un ítem (juego) a una sección específica de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) destino dentro de la Tier List.
     * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    addItemToTierListSection(tierListPublicId: string, sectionInternalId: number, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) directamente a la sección \'Juegos por Clasificar\' de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la sección \'Juegos por Clasificar\'. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
     * @summary Añadir o mover un ítem (juego) a la sección \'Sin Clasificar\' de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem en la sección \&#39;Sin Clasificar\&#39;.
     * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    addItemToUnclassifiedSection(tierListPublicId: string, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado de una Tier List añadir una nueva sección personalizada. Existe un límite en la cantidad de secciones personalizables que se pueden añadir. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Añadir una nueva sección (tier) a una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá la nueva sección.
     * @param {TierSectionRequestDTO} tierSectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    addSectionToTierList(tierListPublicId: string, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al usuario autenticado crear una nueva Tier List de tipo \'PROFILE_GLOBAL\'. Se requiere un nombre para la lista y opcionalmente una descripción y si es pública. Se crearán secciones por defecto (S, A, B, C, D y \'Juegos por Clasificar\'). Requiere autenticación.
     * @summary Crear una nueva Tier List de perfil para el usuario autenticado
     * @param {TierListCreateRequestDTO} tierListCreateRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    createProfileTierList(tierListCreateRequestDTO: TierListCreateRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado de una Tier List eliminarla permanentemente. Esto también eliminará todas las secciones y los ítems contenidos en ella. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Eliminar una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    deleteTierList(tierListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Recupera una lista de todas las Tier Lists de tipo \'PROFILE_GLOBAL\' creadas por el usuario actualmente autenticado. Cada Tier List incluye sus secciones y los ítems clasificados. Requiere autenticación.
     * @summary Obtener todas las Tier Lists de perfil del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    getAllProfileTierListsForCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<Array<TierListResponseDTO>>;

    /**
     * Recupera una lista de todas las Tier Lists que han sido marcadas como públicas por sus creadores. Cada Tier List incluye sus secciones y los ítems clasificados. Las listas se devuelven ordenadas por la fecha de última actualización. Este endpoint es público y no requiere autenticación.
     * @summary Obtener todas las Tier Lists públicas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    getAllPublicTierLists(options?: RawAxiosRequestConfig): AxiosPromise<Array<TierListResponseDTO>>;

    /**
     * Recupera la Tier List de tipo \'FROM_GAMELIST\' asociada a la GameList especificada por su ID público. Si no existe una Tier List para esa GameList, se crea una nueva automáticamente con secciones por defecto y se sincroniza con los juegos de la GameList (añadiéndolos a la sección \'Sin Clasificar\'). Este endpoint es público si la GameList y la TierList resultante son públicas. Si la GameList es privada, se requiere autenticación y ser el propietario para acceder o crear la TierList asociada. Si se proporciona un token JWT válido, la respuesta puede incluir información adicional si el usuario es el propietario.
     * @summary Obtener o crear la Tier List asociada a una GameList específica
     * @param {string} gameListPublicId ID público (UUID) de la GameList para la cual se obtendrá o creará la Tier List.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    getOrCreateTierListForGameList(gameListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Recupera los detalles completos de una Tier List (incluyendo secciones e ítems) utilizando su ID público (UUID). Si la Tier List es pública, cualquiera puede acceder a ella. Si la Tier List es privada, solo el propietario autenticado puede acceder. La autenticación (JWT) es opcional; si se proporciona un token válido y la lista es privada, se verificará la propiedad.
     * @summary Obtener una Tier List específica por su ID público
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    getTierListByPublicId(tierListPublicId: string, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado mover un ítem existente (identificado por `tierListItemInternalId`) a una nueva sección (`target_section_internal_id`) y/o a una nueva posición (`new_order`) dentro de esa sección en una Tier List específica. Para Tier Lists de tipo \'FROM_GAMELIST\', se verifica que el juego del ítem aún pertenezca a la GameList origen. Requiere autenticación y ser propietario de la Tier List.
     * @summary Mover un ítem (juego) dentro de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene el ítem a mover.
     * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a mover.
     * @param {TierListItemMoveRequestDTO} tierListItemMoveRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    moveItemInTierList(tierListPublicId: string, tierListItemInternalId: number, tierListItemMoveRequestDTO: TierListItemMoveRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado eliminar un ítem específico (identificado por `tierListItemInternalId`) de una de sus Tier Lists de tipo \'PROFILE_GLOBAL\'. Esto no elimina el juego de la biblioteca general del usuario, solo de esta Tier List. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Requiere autenticación y ser propietario.
     * @summary Eliminar un ítem (juego) de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará el ítem.
     * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a eliminar de la Tier List.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    removeItemFromTierList(tierListPublicId: string, tierListItemInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado de una Tier List eliminar una de sus secciones personalizadas. La sección por defecto \'Juegos por Clasificar\' no puede ser eliminada. Debe quedar al menos una sección personalizable tras la eliminación. Si la sección eliminada contenía ítems (juegos), estos serán movidos a la sección \'Juegos por Clasificar\'. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Eliminar una sección (tier) de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará la sección.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    removeSectionFromTierList(tierListPublicId: string, sectionInternalId: number, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado de una Tier List modificar sus metadatos como el nombre, la descripción y el estado de visibilidad (pública/privada). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Actualizar los metadatos de una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a actualizar.
     * @param {TierListUpdateRequestDTO} tierListUpdateRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    updateTierListMetadata(tierListPublicId: string, tierListUpdateRequestDTO: TierListUpdateRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

    /**
     * Permite al propietario autenticado de una Tier List cambiar las propiedades de una de sus secciones, como el nombre y el color. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Actualizar una sección (tier) específica de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene la sección a actualizar.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) cuyo nombre se va a actualizar.
     * @param {TierSectionRequestDTO} tierSectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApiInterface
     */
    updateTierSection(tierListPublicId: string, sectionInternalId: number, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<TierListResponseDTO>;

}

/**
 * TierListControllerApi - object-oriented interface
 * @export
 * @class TierListControllerApi
 * @extends {BaseAPI}
 */
export class TierListControllerApi extends BaseAPI implements TierListControllerApiInterface {
    /**
     * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) a una sección específica de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la nueva sección y posición. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\' ni para añadir a la sección \'Juegos por Clasificar\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
     * @summary Añadir o mover un ítem (juego) a una sección específica de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) destino dentro de la Tier List.
     * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public addItemToTierListSection(tierListPublicId: string, sectionInternalId: number, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).addItemToTierListSection(tierListPublicId, sectionInternalId, tierListItemAddRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado añadir un juego de su biblioteca (UserGame) directamente a la sección \'Juegos por Clasificar\' de una Tier List de tipo \'PROFILE_GLOBAL\'. Si el juego ya está en otra sección de esta Tier List, se moverá a la sección \'Juegos por Clasificar\'. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Se puede especificar el orden del ítem dentro de la sección. Requiere autenticación y ser propietario.
     * @summary Añadir o mover un ítem (juego) a la sección \'Sin Clasificar\' de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá el ítem en la sección \&#39;Sin Clasificar\&#39;.
     * @param {TierListItemAddRequestDTO} tierListItemAddRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public addItemToUnclassifiedSection(tierListPublicId: string, tierListItemAddRequestDTO: TierListItemAddRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).addItemToUnclassifiedSection(tierListPublicId, tierListItemAddRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado de una Tier List añadir una nueva sección personalizada. Existe un límite en la cantidad de secciones personalizables que se pueden añadir. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Añadir una nueva sección (tier) a una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a la que se añadirá la nueva sección.
     * @param {TierSectionRequestDTO} tierSectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public addSectionToTierList(tierListPublicId: string, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).addSectionToTierList(tierListPublicId, tierSectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado crear una nueva Tier List de tipo \'PROFILE_GLOBAL\'. Se requiere un nombre para la lista y opcionalmente una descripción y si es pública. Se crearán secciones por defecto (S, A, B, C, D y \'Juegos por Clasificar\'). Requiere autenticación.
     * @summary Crear una nueva Tier List de perfil para el usuario autenticado
     * @param {TierListCreateRequestDTO} tierListCreateRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public createProfileTierList(tierListCreateRequestDTO: TierListCreateRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).createProfileTierList(tierListCreateRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado de una Tier List eliminarla permanentemente. Esto también eliminará todas las secciones y los ítems contenidos en ella. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Eliminar una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public deleteTierList(tierListPublicId: string, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).deleteTierList(tierListPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las Tier Lists de tipo \'PROFILE_GLOBAL\' creadas por el usuario actualmente autenticado. Cada Tier List incluye sus secciones y los ítems clasificados. Requiere autenticación.
     * @summary Obtener todas las Tier Lists de perfil del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public getAllProfileTierListsForCurrentUser(options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).getAllProfileTierListsForCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera una lista de todas las Tier Lists que han sido marcadas como públicas por sus creadores. Cada Tier List incluye sus secciones y los ítems clasificados. Las listas se devuelven ordenadas por la fecha de última actualización. Este endpoint es público y no requiere autenticación.
     * @summary Obtener todas las Tier Lists públicas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public getAllPublicTierLists(options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).getAllPublicTierLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera la Tier List de tipo \'FROM_GAMELIST\' asociada a la GameList especificada por su ID público. Si no existe una Tier List para esa GameList, se crea una nueva automáticamente con secciones por defecto y se sincroniza con los juegos de la GameList (añadiéndolos a la sección \'Sin Clasificar\'). Este endpoint es público si la GameList y la TierList resultante son públicas. Si la GameList es privada, se requiere autenticación y ser el propietario para acceder o crear la TierList asociada. Si se proporciona un token JWT válido, la respuesta puede incluir información adicional si el usuario es el propietario.
     * @summary Obtener o crear la Tier List asociada a una GameList específica
     * @param {string} gameListPublicId ID público (UUID) de la GameList para la cual se obtendrá o creará la Tier List.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public getOrCreateTierListForGameList(gameListPublicId: string, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).getOrCreateTierListForGameList(gameListPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles completos de una Tier List (incluyendo secciones e ítems) utilizando su ID público (UUID). Si la Tier List es pública, cualquiera puede acceder a ella. Si la Tier List es privada, solo el propietario autenticado puede acceder. La autenticación (JWT) es opcional; si se proporciona un token válido y la lista es privada, se verificará la propiedad.
     * @summary Obtener una Tier List específica por su ID público
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public getTierListByPublicId(tierListPublicId: string, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).getTierListByPublicId(tierListPublicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado mover un ítem existente (identificado por `tierListItemInternalId`) a una nueva sección (`target_section_internal_id`) y/o a una nueva posición (`new_order`) dentro de esa sección en una Tier List específica. Para Tier Lists de tipo \'FROM_GAMELIST\', se verifica que el juego del ítem aún pertenezca a la GameList origen. Requiere autenticación y ser propietario de la Tier List.
     * @summary Mover un ítem (juego) dentro de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene el ítem a mover.
     * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a mover.
     * @param {TierListItemMoveRequestDTO} tierListItemMoveRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public moveItemInTierList(tierListPublicId: string, tierListItemInternalId: number, tierListItemMoveRequestDTO: TierListItemMoveRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).moveItemInTierList(tierListPublicId, tierListItemInternalId, tierListItemMoveRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado eliminar un ítem específico (identificado por `tierListItemInternalId`) de una de sus Tier Lists de tipo \'PROFILE_GLOBAL\'. Esto no elimina el juego de la biblioteca general del usuario, solo de esta Tier List. No se puede usar este endpoint para Tier Lists de tipo \'FROM_GAMELIST\'. Requiere autenticación y ser propietario.
     * @summary Eliminar un ítem (juego) de una Tier List de perfil
     * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará el ítem.
     * @param {number} tierListItemInternalId ID interno (Long) del TierListItem a eliminar de la Tier List.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public removeItemFromTierList(tierListPublicId: string, tierListItemInternalId: number, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).removeItemFromTierList(tierListPublicId, tierListItemInternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado de una Tier List eliminar una de sus secciones personalizadas. La sección por defecto \'Juegos por Clasificar\' no puede ser eliminada. Debe quedar al menos una sección personalizable tras la eliminación. Si la sección eliminada contenía ítems (juegos), estos serán movidos a la sección \'Juegos por Clasificar\'. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Eliminar una sección (tier) de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List de la cual se eliminará la sección.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) a eliminar.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public removeSectionFromTierList(tierListPublicId: string, sectionInternalId: number, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).removeSectionFromTierList(tierListPublicId, sectionInternalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado de una Tier List modificar sus metadatos como el nombre, la descripción y el estado de visibilidad (pública/privada). Solo los campos proporcionados en el cuerpo de la solicitud serán actualizados. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Actualizar los metadatos de una Tier List existente
     * @param {string} tierListPublicId ID público (UUID) de la Tier List a actualizar.
     * @param {TierListUpdateRequestDTO} tierListUpdateRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public updateTierListMetadata(tierListPublicId: string, tierListUpdateRequestDTO: TierListUpdateRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).updateTierListMetadata(tierListPublicId, tierListUpdateRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al propietario autenticado de una Tier List cambiar las propiedades de una de sus secciones, como el nombre y el color. Requiere autenticación y ser el propietario de la Tier List.
     * @summary Actualizar una sección (tier) específica de una Tier List
     * @param {string} tierListPublicId ID público (UUID) de la Tier List que contiene la sección a actualizar.
     * @param {number} sectionInternalId ID interno (Long) de la sección (tier) cuyo nombre se va a actualizar.
     * @param {TierSectionRequestDTO} tierSectionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TierListControllerApi
     */
    public updateTierSection(tierListPublicId: string, sectionInternalId: number, tierSectionRequestDTO: TierSectionRequestDTO, options?: RawAxiosRequestConfig) {
        return TierListControllerApiFp(this.configuration).updateTierSection(tierListPublicId, sectionInternalId, tierSectionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserGameLibraryControllerApi - axios parameter creator
 * @export
 */
export const UserGameLibraryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite al usuario autenticado añadir un juego (identificado por su IGDB ID) a su biblioteca personal o actualizar una entrada existente. Si el juego no existe en la base de datos local, se intentará obtener de IGDB. Se proporcionan datos específicos del usuario para este juego (estado, puntuación, plataforma, etc.). Requiere autenticación.
         * @summary Añadir o actualizar un juego en la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a añadir o actualizar en la biblioteca.
         * @param {UserGameDataDTO} userGameDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateGameInMyLibrary: async (igdbId: number, userGameDataDTO: UserGameDataDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'igdbId' is not null or undefined
            assertParamExists('addOrUpdateGameInMyLibrary', 'igdbId', igdbId)
            // verify required parameter 'userGameDataDTO' is not null or undefined
            assertParamExists('addOrUpdateGameInMyLibrary', 'userGameDataDTO', userGameDataDTO)
            const localVarPath = `/api/v1/users/me/library/games/{igdbId}`
                .replace(`{${"igdbId"}}`, encodeURIComponent(String(igdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userGameDataDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera información detallada sobre un juego específico, identificado por su IGDB ID. Este endpoint es público. Si se proporciona un token JWT de autenticación válido, la respuesta incluirá adicionalmente los datos específicos del usuario para ese juego (si existen en su biblioteca), como su estado, puntuación, etc. Si no se proporciona autenticación o el token es inválido, solo se devolverá la información pública del juego y los comentarios públicos.
         * @summary Obtener detalles completos de un juego
         * @param {number} igdbId ID de IGDB del juego para el cual se solicitan los detalles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameDetails: async (igdbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'igdbId' is not null or undefined
            assertParamExists('getGameDetails', 'igdbId', igdbId)
            const localVarPath = `/api/v1/games/{igdbId}/details`
                .replace(`{${"igdbId"}}`, encodeURIComponent(String(igdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera todas las entradas de juegos que el usuario actualmente autenticado tiene en su biblioteca personal, incluyendo el estado, puntuación, plataforma y otros datos específicos del usuario para cada juego. Requiere autenticación.
         * @summary Obtener la biblioteca completa de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGameLibrary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/library/games`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera la biblioteca de juegos de un usuario específico, sujeto a los permisos de visibilidad del perfil (PÚBLICO o SOLO_AMIGOS). Si el perfil es SOLO_AMIGOS, se requiere autenticación para verificar la amistad. Este endpoint es público.
         * @summary Obtener la biblioteca de un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario cuya biblioteca se desea obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserLibrary: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getPublicUserLibrary', 'publicId', publicId)
            const localVarPath = `/api/v1/users/public/{publicId}/library`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles de un juego específico (identificado por su IGDB ID) tal como existe en la biblioteca personal del usuario autenticado. Esto incluye el estado, puntuación, y otros datos que el usuario haya registrado para ese juego. Requiere autenticación.
         * @summary Obtener un juego específico de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a obtener de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificGameFromMyLibrary: async (igdbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'igdbId' is not null or undefined
            assertParamExists('getSpecificGameFromMyLibrary', 'igdbId', igdbId)
            const localVarPath = `/api/v1/users/me/library/games/{igdbId}`
                .replace(`{${"igdbId"}}`, encodeURIComponent(String(igdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su IGDB ID) de su biblioteca personal. Requiere autenticación.
         * @summary Eliminar un juego de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a eliminar de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGameFromMyLibrary: async (igdbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'igdbId' is not null or undefined
            assertParamExists('removeGameFromMyLibrary', 'igdbId', igdbId)
            const localVarPath = `/api/v1/users/me/library/games/{igdbId}`
                .replace(`{${"igdbId"}}`, encodeURIComponent(String(igdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserGameLibraryControllerApi - functional programming interface
 * @export
 */
export const UserGameLibraryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserGameLibraryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite al usuario autenticado añadir un juego (identificado por su IGDB ID) a su biblioteca personal o actualizar una entrada existente. Si el juego no existe en la base de datos local, se intentará obtener de IGDB. Se proporcionan datos específicos del usuario para este juego (estado, puntuación, plataforma, etc.). Requiere autenticación.
         * @summary Añadir o actualizar un juego en la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a añadir o actualizar en la biblioteca.
         * @param {UserGameDataDTO} userGameDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrUpdateGameInMyLibrary(igdbId: number, userGameDataDTO: UserGameDataDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGameResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrUpdateGameInMyLibrary(igdbId, userGameDataDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.addOrUpdateGameInMyLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera información detallada sobre un juego específico, identificado por su IGDB ID. Este endpoint es público. Si se proporciona un token JWT de autenticación válido, la respuesta incluirá adicionalmente los datos específicos del usuario para ese juego (si existen en su biblioteca), como su estado, puntuación, etc. Si no se proporciona autenticación o el token es inválido, solo se devolverá la información pública del juego y los comentarios públicos.
         * @summary Obtener detalles completos de un juego
         * @param {number} igdbId ID de IGDB del juego para el cual se solicitan los detalles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGameDetails(igdbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameDetailDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGameDetails(igdbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.getGameDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera todas las entradas de juegos que el usuario actualmente autenticado tiene en su biblioteca personal, incluyendo el estado, puntuación, plataforma y otros datos específicos del usuario para cada juego. Requiere autenticación.
         * @summary Obtener la biblioteca completa de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyGameLibrary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserGameResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGameLibrary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.getMyGameLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera la biblioteca de juegos de un usuario específico, sujeto a los permisos de visibilidad del perfil (PÚBLICO o SOLO_AMIGOS). Si el perfil es SOLO_AMIGOS, se requiere autenticación para verificar la amistad. Este endpoint es público.
         * @summary Obtener la biblioteca de un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario cuya biblioteca se desea obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUserLibrary(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserGameResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUserLibrary(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.getPublicUserLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles de un juego específico (identificado por su IGDB ID) tal como existe en la biblioteca personal del usuario autenticado. Esto incluye el estado, puntuación, y otros datos que el usuario haya registrado para ese juego. Requiere autenticación.
         * @summary Obtener un juego específico de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a obtener de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecificGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGameResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpecificGameFromMyLibrary(igdbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.getSpecificGameFromMyLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su IGDB ID) de su biblioteca personal. Requiere autenticación.
         * @summary Eliminar un juego de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a eliminar de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeGameFromMyLibrary(igdbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserGameLibraryControllerApi.removeGameFromMyLibrary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserGameLibraryControllerApi - factory interface
 * @export
 */
export const UserGameLibraryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserGameLibraryControllerApiFp(configuration)
    return {
        /**
         * Permite al usuario autenticado añadir un juego (identificado por su IGDB ID) a su biblioteca personal o actualizar una entrada existente. Si el juego no existe en la base de datos local, se intentará obtener de IGDB. Se proporcionan datos específicos del usuario para este juego (estado, puntuación, plataforma, etc.). Requiere autenticación.
         * @summary Añadir o actualizar un juego en la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a añadir o actualizar en la biblioteca.
         * @param {UserGameDataDTO} userGameDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateGameInMyLibrary(igdbId: number, userGameDataDTO: UserGameDataDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserGameResponseDTO> {
            return localVarFp.addOrUpdateGameInMyLibrary(igdbId, userGameDataDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera información detallada sobre un juego específico, identificado por su IGDB ID. Este endpoint es público. Si se proporciona un token JWT de autenticación válido, la respuesta incluirá adicionalmente los datos específicos del usuario para ese juego (si existen en su biblioteca), como su estado, puntuación, etc. Si no se proporciona autenticación o el token es inválido, solo se devolverá la información pública del juego y los comentarios públicos.
         * @summary Obtener detalles completos de un juego
         * @param {number} igdbId ID de IGDB del juego para el cual se solicitan los detalles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGameDetails(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<GameDetailDTO> {
            return localVarFp.getGameDetails(igdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera todas las entradas de juegos que el usuario actualmente autenticado tiene en su biblioteca personal, incluyendo el estado, puntuación, plataforma y otros datos específicos del usuario para cada juego. Requiere autenticación.
         * @summary Obtener la biblioteca completa de juegos del usuario autenticado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyGameLibrary(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserGameResponseDTO>> {
            return localVarFp.getMyGameLibrary(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera la biblioteca de juegos de un usuario específico, sujeto a los permisos de visibilidad del perfil (PÚBLICO o SOLO_AMIGOS). Si el perfil es SOLO_AMIGOS, se requiere autenticación para verificar la amistad. Este endpoint es público.
         * @summary Obtener la biblioteca de un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario cuya biblioteca se desea obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserLibrary(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserGameResponseDTO>> {
            return localVarFp.getPublicUserLibrary(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles de un juego específico (identificado por su IGDB ID) tal como existe en la biblioteca personal del usuario autenticado. Esto incluye el estado, puntuación, y otros datos que el usuario haya registrado para ese juego. Requiere autenticación.
         * @summary Obtener un juego específico de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a obtener de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecificGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGameResponseDTO> {
            return localVarFp.getSpecificGameFromMyLibrary(igdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado eliminar un juego específico (identificado por su IGDB ID) de su biblioteca personal. Requiere autenticación.
         * @summary Eliminar un juego de la biblioteca del usuario autenticado
         * @param {number} igdbId ID de IGDB del juego a eliminar de la biblioteca del usuario.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeGameFromMyLibrary(igdbId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserGameLibraryControllerApi - interface
 * @export
 * @interface UserGameLibraryControllerApi
 */
export interface UserGameLibraryControllerApiInterface {
    /**
     * Permite al usuario autenticado añadir un juego (identificado por su IGDB ID) a su biblioteca personal o actualizar una entrada existente. Si el juego no existe en la base de datos local, se intentará obtener de IGDB. Se proporcionan datos específicos del usuario para este juego (estado, puntuación, plataforma, etc.). Requiere autenticación.
     * @summary Añadir o actualizar un juego en la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a añadir o actualizar en la biblioteca.
     * @param {UserGameDataDTO} userGameDataDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    addOrUpdateGameInMyLibrary(igdbId: number, userGameDataDTO: UserGameDataDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserGameResponseDTO>;

    /**
     * Recupera información detallada sobre un juego específico, identificado por su IGDB ID. Este endpoint es público. Si se proporciona un token JWT de autenticación válido, la respuesta incluirá adicionalmente los datos específicos del usuario para ese juego (si existen en su biblioteca), como su estado, puntuación, etc. Si no se proporciona autenticación o el token es inválido, solo se devolverá la información pública del juego y los comentarios públicos.
     * @summary Obtener detalles completos de un juego
     * @param {number} igdbId ID de IGDB del juego para el cual se solicitan los detalles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    getGameDetails(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<GameDetailDTO>;

    /**
     * Recupera todas las entradas de juegos que el usuario actualmente autenticado tiene en su biblioteca personal, incluyendo el estado, puntuación, plataforma y otros datos específicos del usuario para cada juego. Requiere autenticación.
     * @summary Obtener la biblioteca completa de juegos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    getMyGameLibrary(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserGameResponseDTO>>;

    /**
     * Recupera la biblioteca de juegos de un usuario específico, sujeto a los permisos de visibilidad del perfil (PÚBLICO o SOLO_AMIGOS). Si el perfil es SOLO_AMIGOS, se requiere autenticación para verificar la amistad. Este endpoint es público.
     * @summary Obtener la biblioteca de un usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario cuya biblioteca se desea obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    getPublicUserLibrary(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserGameResponseDTO>>;

    /**
     * Recupera los detalles de un juego específico (identificado por su IGDB ID) tal como existe en la biblioteca personal del usuario autenticado. Esto incluye el estado, puntuación, y otros datos que el usuario haya registrado para ese juego. Requiere autenticación.
     * @summary Obtener un juego específico de la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a obtener de la biblioteca del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    getSpecificGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserGameResponseDTO>;

    /**
     * Permite al usuario autenticado eliminar un juego específico (identificado por su IGDB ID) de su biblioteca personal. Requiere autenticación.
     * @summary Eliminar un juego de la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a eliminar de la biblioteca del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApiInterface
     */
    removeGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * UserGameLibraryControllerApi - object-oriented interface
 * @export
 * @class UserGameLibraryControllerApi
 * @extends {BaseAPI}
 */
export class UserGameLibraryControllerApi extends BaseAPI implements UserGameLibraryControllerApiInterface {
    /**
     * Permite al usuario autenticado añadir un juego (identificado por su IGDB ID) a su biblioteca personal o actualizar una entrada existente. Si el juego no existe en la base de datos local, se intentará obtener de IGDB. Se proporcionan datos específicos del usuario para este juego (estado, puntuación, plataforma, etc.). Requiere autenticación.
     * @summary Añadir o actualizar un juego en la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a añadir o actualizar en la biblioteca.
     * @param {UserGameDataDTO} userGameDataDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public addOrUpdateGameInMyLibrary(igdbId: number, userGameDataDTO: UserGameDataDTO, options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).addOrUpdateGameInMyLibrary(igdbId, userGameDataDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera información detallada sobre un juego específico, identificado por su IGDB ID. Este endpoint es público. Si se proporciona un token JWT de autenticación válido, la respuesta incluirá adicionalmente los datos específicos del usuario para ese juego (si existen en su biblioteca), como su estado, puntuación, etc. Si no se proporciona autenticación o el token es inválido, solo se devolverá la información pública del juego y los comentarios públicos.
     * @summary Obtener detalles completos de un juego
     * @param {number} igdbId ID de IGDB del juego para el cual se solicitan los detalles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public getGameDetails(igdbId: number, options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).getGameDetails(igdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera todas las entradas de juegos que el usuario actualmente autenticado tiene en su biblioteca personal, incluyendo el estado, puntuación, plataforma y otros datos específicos del usuario para cada juego. Requiere autenticación.
     * @summary Obtener la biblioteca completa de juegos del usuario autenticado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public getMyGameLibrary(options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).getMyGameLibrary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera la biblioteca de juegos de un usuario específico, sujeto a los permisos de visibilidad del perfil (PÚBLICO o SOLO_AMIGOS). Si el perfil es SOLO_AMIGOS, se requiere autenticación para verificar la amistad. Este endpoint es público.
     * @summary Obtener la biblioteca de un usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario cuya biblioteca se desea obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public getPublicUserLibrary(publicId: string, options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).getPublicUserLibrary(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles de un juego específico (identificado por su IGDB ID) tal como existe en la biblioteca personal del usuario autenticado. Esto incluye el estado, puntuación, y otros datos que el usuario haya registrado para ese juego. Requiere autenticación.
     * @summary Obtener un juego específico de la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a obtener de la biblioteca del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public getSpecificGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).getSpecificGameFromMyLibrary(igdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado eliminar un juego específico (identificado por su IGDB ID) de su biblioteca personal. Requiere autenticación.
     * @summary Eliminar un juego de la biblioteca del usuario autenticado
     * @param {number} igdbId ID de IGDB del juego a eliminar de la biblioteca del usuario.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserGameLibraryControllerApi
     */
    public removeGameFromMyLibrary(igdbId: number, options?: RawAxiosRequestConfig) {
        return UserGameLibraryControllerApiFp(this.configuration).removeGameFromMyLibrary(igdbId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsuariosApi - axios parameter creator
 * @export
 */
export const UsuariosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permite al usuario autenticado cambiar su contraseña actual por una nueva. Se requiere la contraseña actual para la verificación. Requiere un token JWT válido.
         * @summary Cambiar la contraseña del usuario autenticado actualmente
         * @param {PasswordChangeDTO} passwordChangeDTO DTO con la contraseña actual y la nueva contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyPassword: async (passwordChangeDTO: PasswordChangeDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeDTO' is not null or undefined
            assertParamExists('changeMyPassword', 'passwordChangeDTO', passwordChangeDTO)
            const localVarPath = `/api/v1/usuarios/me/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado solicitar la eliminación de su cuenta. Se requiere la contraseña actual para confirmación. La cuenta se marcará para eliminación y se borrará permanentemente después de un período de gracia. Tras esta operación, la sesión actual del usuario se invalidará. Requiere un token JWT válido.
         * @summary Programar la eliminación de la cuenta del usuario autenticado
         * @param {AccountDeleteDTO} accountDeleteDTO DTO que contiene la contraseña actual del usuario para confirmar la eliminación de la cuenta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyAccount: async (accountDeleteDTO: AccountDeleteDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountDeleteDTO' is not null or undefined
            assertParamExists('deleteMyAccount', 'accountDeleteDTO', accountDeleteDTO)
            const localVarPath = `/api/v1/usuarios/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountDeleteDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles del perfil y preferencias del usuario que ha iniciado sesión. Requiere un token JWT válido en la cabecera de autorización.
         * @summary Obtener los datos del usuario autenticado actualmente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAuthenticatedUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/usuarios/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera los detalles de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsuarioByPublicId: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getUsuarioByPublicId', 'publicId', publicId)
            const localVarPath = `/api/v1/usuarios/public/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Recupera un resumen de información pública de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un resumen de usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsuarioSummaryByPublicId: async (publicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicId' is not null or undefined
            assertParamExists('getUsuarioSummaryByPublicId', 'publicId', publicId)
            const localVarPath = `/api/v1/usuarios/public/summary/{publicId}`
                .replace(`{${"publicId"}}`, encodeURIComponent(String(publicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea una nueva cuenta de usuario en el sistema. Tras el registro exitoso, se enviará un correo electrónico de verificación a la dirección proporcionada para activar la cuenta.
         * @summary Registrar un nuevo usuario
         * @param {UserCreateDTO} userCreateDTO Datos del nuevo usuario a registrar. Todos los campos son obligatorios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrarUsuario: async (userCreateDTO: UserCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateDTO' is not null or undefined
            assertParamExists('registrarUsuario', 'userCreateDTO', userCreateDTO)
            const localVarPath = `/api/v1/usuarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite a un usuario autenticado buscar otros usuarios en el sistema por su nombre de usuario. La búsqueda es parcial (contiene) e ignora mayúsculas/minúsculas. El propio usuario que realiza la búsqueda será excluido de los resultados. Se requiere un término de búsqueda de al menos 2 caracteres. Requiere autenticación.
         * @summary Buscar usuarios por nombre de usuario
         * @param {string} username Término de búsqueda para el nombre de usuario. Debe tener al menos 2 caracteres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('searchUsersByUsername', 'username', username)
            const localVarPath = `/api/v1/usuarios/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado modificar los detalles de su perfil, como el nombre de usuario, tema, foto de perfil, preferencias de notificación y visibilidad del perfil. Requiere un token JWT válido.
         * @summary Actualizar el perfil del usuario autenticado actualmente
         * @param {UserProfileUpdateDTO} userProfileUpdateDTO Datos del perfil del usuario a actualizar. Solo se actualizarán los campos proporcionados.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserProfile: async (userProfileUpdateDTO: UserProfileUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileUpdateDTO' is not null or undefined
            assertParamExists('updateCurrentUserProfile', 'userProfileUpdateDTO', userProfileUpdateDTO)
            const localVarPath = `/api/v1/usuarios/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permite al usuario autenticado subir un nuevo archivo de imagen para su foto de perfil. El archivo debe ser de un formato permitido (JPEG, PNG, GIF) y no exceder el tamaño máximo configurado. Si ya existe una foto de perfil, será reemplazada. Requiere autenticación.
         * @summary Subir o actualizar la foto de perfil del usuario autenticado
         * @param {File} file El archivo de imagen a subir como foto de perfil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfilePicture: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadProfilePicture', 'file', file)
            const localVarPath = `/api/v1/usuarios/me/profile-picture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsuariosApi - functional programming interface
 * @export
 */
export const UsuariosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsuariosApiAxiosParamCreator(configuration)
    return {
        /**
         * Permite al usuario autenticado cambiar su contraseña actual por una nueva. Se requiere la contraseña actual para la verificación. Requiere un token JWT válido.
         * @summary Cambiar la contraseña del usuario autenticado actualmente
         * @param {PasswordChangeDTO} passwordChangeDTO DTO con la contraseña actual y la nueva contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeMyPassword(passwordChangeDTO: PasswordChangeDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeMyPassword(passwordChangeDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.changeMyPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado solicitar la eliminación de su cuenta. Se requiere la contraseña actual para confirmación. La cuenta se marcará para eliminación y se borrará permanentemente después de un período de gracia. Tras esta operación, la sesión actual del usuario se invalidará. Requiere un token JWT válido.
         * @summary Programar la eliminación de la cuenta del usuario autenticado
         * @param {AccountDeleteDTO} accountDeleteDTO DTO que contiene la contraseña actual del usuario para confirmar la eliminación de la cuenta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMyAccount(accountDeleteDTO: AccountDeleteDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMyAccount(accountDeleteDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.deleteMyAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles del perfil y preferencias del usuario que ha iniciado sesión. Requiere un token JWT válido en la cabecera de autorización.
         * @summary Obtener los datos del usuario autenticado actualmente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentAuthenticatedUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentAuthenticatedUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.getCurrentAuthenticatedUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera los detalles de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsuarioByPublicId(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsuarioByPublicId(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.getUsuarioByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Recupera un resumen de información pública de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un resumen de usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsuarioSummaryByPublicId(publicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearchResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsuarioSummaryByPublicId(publicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.getUsuarioSummaryByPublicId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea una nueva cuenta de usuario en el sistema. Tras el registro exitoso, se enviará un correo electrónico de verificación a la dirección proporcionada para activar la cuenta.
         * @summary Registrar un nuevo usuario
         * @param {UserCreateDTO} userCreateDTO Datos del nuevo usuario a registrar. Todos los campos son obligatorios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registrarUsuario(userCreateDTO: UserCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registrarUsuario(userCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.registrarUsuario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite a un usuario autenticado buscar otros usuarios en el sistema por su nombre de usuario. La búsqueda es parcial (contiene) e ignora mayúsculas/minúsculas. El propio usuario que realiza la búsqueda será excluido de los resultados. Se requiere un término de búsqueda de al menos 2 caracteres. Requiere autenticación.
         * @summary Buscar usuarios por nombre de usuario
         * @param {string} username Término de búsqueda para el nombre de usuario. Debe tener al menos 2 caracteres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSearchResultDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.searchUsersByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado modificar los detalles de su perfil, como el nombre de usuario, tema, foto de perfil, preferencias de notificación y visibilidad del perfil. Requiere un token JWT válido.
         * @summary Actualizar el perfil del usuario autenticado actualmente
         * @param {UserProfileUpdateDTO} userProfileUpdateDTO Datos del perfil del usuario a actualizar. Solo se actualizarán los campos proporcionados.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUserProfile(userProfileUpdateDTO: UserProfileUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUserProfile(userProfileUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.updateCurrentUserProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permite al usuario autenticado subir un nuevo archivo de imagen para su foto de perfil. El archivo debe ser de un formato permitido (JPEG, PNG, GIF) y no exceder el tamaño máximo configurado. Si ya existe una foto de perfil, será reemplazada. Requiere autenticación.
         * @summary Subir o actualizar la foto de perfil del usuario autenticado
         * @param {File} file El archivo de imagen a subir como foto de perfil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProfilePicture(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProfilePicture(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsuariosApi.uploadProfilePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsuariosApi - factory interface
 * @export
 */
export const UsuariosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsuariosApiFp(configuration)
    return {
        /**
         * Permite al usuario autenticado cambiar su contraseña actual por una nueva. Se requiere la contraseña actual para la verificación. Requiere un token JWT válido.
         * @summary Cambiar la contraseña del usuario autenticado actualmente
         * @param {PasswordChangeDTO} passwordChangeDTO DTO con la contraseña actual y la nueva contraseña.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeMyPassword(passwordChangeDTO: PasswordChangeDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.changeMyPassword(passwordChangeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado solicitar la eliminación de su cuenta. Se requiere la contraseña actual para confirmación. La cuenta se marcará para eliminación y se borrará permanentemente después de un período de gracia. Tras esta operación, la sesión actual del usuario se invalidará. Requiere un token JWT válido.
         * @summary Programar la eliminación de la cuenta del usuario autenticado
         * @param {AccountDeleteDTO} accountDeleteDTO DTO que contiene la contraseña actual del usuario para confirmar la eliminación de la cuenta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyAccount(accountDeleteDTO: AccountDeleteDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteMyAccount(accountDeleteDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles del perfil y preferencias del usuario que ha iniciado sesión. Requiere un token JWT válido en la cabecera de autorización.
         * @summary Obtener los datos del usuario autenticado actualmente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAuthenticatedUser(options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.getCurrentAuthenticatedUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera los detalles de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsuarioByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.getUsuarioByPublicId(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Recupera un resumen de información pública de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
         * @summary Obtener un resumen de usuario por su ID público
         * @param {string} publicId ID público (UUID) del usuario a obtener.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsuarioSummaryByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSearchResultDTO> {
            return localVarFp.getUsuarioSummaryByPublicId(publicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea una nueva cuenta de usuario en el sistema. Tras el registro exitoso, se enviará un correo electrónico de verificación a la dirección proporcionada para activar la cuenta.
         * @summary Registrar un nuevo usuario
         * @param {UserCreateDTO} userCreateDTO Datos del nuevo usuario a registrar. Todos los campos son obligatorios.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrarUsuario(userCreateDTO: UserCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.registrarUsuario(userCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite a un usuario autenticado buscar otros usuarios en el sistema por su nombre de usuario. La búsqueda es parcial (contiene) e ignora mayúsculas/minúsculas. El propio usuario que realiza la búsqueda será excluido de los resultados. Se requiere un término de búsqueda de al menos 2 caracteres. Requiere autenticación.
         * @summary Buscar usuarios por nombre de usuario
         * @param {string} username Término de búsqueda para el nombre de usuario. Debe tener al menos 2 caracteres.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSearchResultDTO>> {
            return localVarFp.searchUsersByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado modificar los detalles de su perfil, como el nombre de usuario, tema, foto de perfil, preferencias de notificación y visibilidad del perfil. Requiere un token JWT válido.
         * @summary Actualizar el perfil del usuario autenticado actualmente
         * @param {UserProfileUpdateDTO} userProfileUpdateDTO Datos del perfil del usuario a actualizar. Solo se actualizarán los campos proporcionados.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUserProfile(userProfileUpdateDTO: UserProfileUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.updateCurrentUserProfile(userProfileUpdateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Permite al usuario autenticado subir un nuevo archivo de imagen para su foto de perfil. El archivo debe ser de un formato permitido (JPEG, PNG, GIF) y no exceder el tamaño máximo configurado. Si ya existe una foto de perfil, será reemplazada. Requiere autenticación.
         * @summary Subir o actualizar la foto de perfil del usuario autenticado
         * @param {File} file El archivo de imagen a subir como foto de perfil.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProfilePicture(file: File, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO> {
            return localVarFp.uploadProfilePicture(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsuariosApi - interface
 * @export
 * @interface UsuariosApi
 */
export interface UsuariosApiInterface {
    /**
     * Permite al usuario autenticado cambiar su contraseña actual por una nueva. Se requiere la contraseña actual para la verificación. Requiere un token JWT válido.
     * @summary Cambiar la contraseña del usuario autenticado actualmente
     * @param {PasswordChangeDTO} passwordChangeDTO DTO con la contraseña actual y la nueva contraseña.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    changeMyPassword(passwordChangeDTO: PasswordChangeDTO, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Permite al usuario autenticado solicitar la eliminación de su cuenta. Se requiere la contraseña actual para confirmación. La cuenta se marcará para eliminación y se borrará permanentemente después de un período de gracia. Tras esta operación, la sesión actual del usuario se invalidará. Requiere un token JWT válido.
     * @summary Programar la eliminación de la cuenta del usuario autenticado
     * @param {AccountDeleteDTO} accountDeleteDTO DTO que contiene la contraseña actual del usuario para confirmar la eliminación de la cuenta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    deleteMyAccount(accountDeleteDTO: AccountDeleteDTO, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * Recupera los detalles del perfil y preferencias del usuario que ha iniciado sesión. Requiere un token JWT válido en la cabecera de autorización.
     * @summary Obtener los datos del usuario autenticado actualmente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    getCurrentAuthenticatedUser(options?: RawAxiosRequestConfig): AxiosPromise<UserDTO>;

    /**
     * Recupera los detalles de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener un usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    getUsuarioByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO>;

    /**
     * Recupera un resumen de información pública de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener un resumen de usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    getUsuarioSummaryByPublicId(publicId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSearchResultDTO>;

    /**
     * Crea una nueva cuenta de usuario en el sistema. Tras el registro exitoso, se enviará un correo electrónico de verificación a la dirección proporcionada para activar la cuenta.
     * @summary Registrar un nuevo usuario
     * @param {UserCreateDTO} userCreateDTO Datos del nuevo usuario a registrar. Todos los campos son obligatorios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    registrarUsuario(userCreateDTO: UserCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO>;

    /**
     * Permite a un usuario autenticado buscar otros usuarios en el sistema por su nombre de usuario. La búsqueda es parcial (contiene) e ignora mayúsculas/minúsculas. El propio usuario que realiza la búsqueda será excluido de los resultados. Se requiere un término de búsqueda de al menos 2 caracteres. Requiere autenticación.
     * @summary Buscar usuarios por nombre de usuario
     * @param {string} username Término de búsqueda para el nombre de usuario. Debe tener al menos 2 caracteres.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    searchUsersByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSearchResultDTO>>;

    /**
     * Permite al usuario autenticado modificar los detalles de su perfil, como el nombre de usuario, tema, foto de perfil, preferencias de notificación y visibilidad del perfil. Requiere un token JWT válido.
     * @summary Actualizar el perfil del usuario autenticado actualmente
     * @param {UserProfileUpdateDTO} userProfileUpdateDTO Datos del perfil del usuario a actualizar. Solo se actualizarán los campos proporcionados.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    updateCurrentUserProfile(userProfileUpdateDTO: UserProfileUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO>;

    /**
     * Permite al usuario autenticado subir un nuevo archivo de imagen para su foto de perfil. El archivo debe ser de un formato permitido (JPEG, PNG, GIF) y no exceder el tamaño máximo configurado. Si ya existe una foto de perfil, será reemplazada. Requiere autenticación.
     * @summary Subir o actualizar la foto de perfil del usuario autenticado
     * @param {File} file El archivo de imagen a subir como foto de perfil.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApiInterface
     */
    uploadProfilePicture(file: File, options?: RawAxiosRequestConfig): AxiosPromise<UserDTO>;

}

/**
 * UsuariosApi - object-oriented interface
 * @export
 * @class UsuariosApi
 * @extends {BaseAPI}
 */
export class UsuariosApi extends BaseAPI implements UsuariosApiInterface {
    /**
     * Permite al usuario autenticado cambiar su contraseña actual por una nueva. Se requiere la contraseña actual para la verificación. Requiere un token JWT válido.
     * @summary Cambiar la contraseña del usuario autenticado actualmente
     * @param {PasswordChangeDTO} passwordChangeDTO DTO con la contraseña actual y la nueva contraseña.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public changeMyPassword(passwordChangeDTO: PasswordChangeDTO, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).changeMyPassword(passwordChangeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado solicitar la eliminación de su cuenta. Se requiere la contraseña actual para confirmación. La cuenta se marcará para eliminación y se borrará permanentemente después de un período de gracia. Tras esta operación, la sesión actual del usuario se invalidará. Requiere un token JWT válido.
     * @summary Programar la eliminación de la cuenta del usuario autenticado
     * @param {AccountDeleteDTO} accountDeleteDTO DTO que contiene la contraseña actual del usuario para confirmar la eliminación de la cuenta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public deleteMyAccount(accountDeleteDTO: AccountDeleteDTO, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).deleteMyAccount(accountDeleteDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles del perfil y preferencias del usuario que ha iniciado sesión. Requiere un token JWT válido en la cabecera de autorización.
     * @summary Obtener los datos del usuario autenticado actualmente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public getCurrentAuthenticatedUser(options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).getCurrentAuthenticatedUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera los detalles de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener un usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public getUsuarioByPublicId(publicId: string, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).getUsuarioByPublicId(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Recupera un resumen de información pública de un usuario específico utilizando su ID público (UUID). Este endpoint es público y no requiere autenticación.
     * @summary Obtener un resumen de usuario por su ID público
     * @param {string} publicId ID público (UUID) del usuario a obtener.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public getUsuarioSummaryByPublicId(publicId: string, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).getUsuarioSummaryByPublicId(publicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea una nueva cuenta de usuario en el sistema. Tras el registro exitoso, se enviará un correo electrónico de verificación a la dirección proporcionada para activar la cuenta.
     * @summary Registrar un nuevo usuario
     * @param {UserCreateDTO} userCreateDTO Datos del nuevo usuario a registrar. Todos los campos son obligatorios.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public registrarUsuario(userCreateDTO: UserCreateDTO, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).registrarUsuario(userCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite a un usuario autenticado buscar otros usuarios en el sistema por su nombre de usuario. La búsqueda es parcial (contiene) e ignora mayúsculas/minúsculas. El propio usuario que realiza la búsqueda será excluido de los resultados. Se requiere un término de búsqueda de al menos 2 caracteres. Requiere autenticación.
     * @summary Buscar usuarios por nombre de usuario
     * @param {string} username Término de búsqueda para el nombre de usuario. Debe tener al menos 2 caracteres.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public searchUsersByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).searchUsersByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado modificar los detalles de su perfil, como el nombre de usuario, tema, foto de perfil, preferencias de notificación y visibilidad del perfil. Requiere un token JWT válido.
     * @summary Actualizar el perfil del usuario autenticado actualmente
     * @param {UserProfileUpdateDTO} userProfileUpdateDTO Datos del perfil del usuario a actualizar. Solo se actualizarán los campos proporcionados.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public updateCurrentUserProfile(userProfileUpdateDTO: UserProfileUpdateDTO, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).updateCurrentUserProfile(userProfileUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permite al usuario autenticado subir un nuevo archivo de imagen para su foto de perfil. El archivo debe ser de un formato permitido (JPEG, PNG, GIF) y no exceder el tamaño máximo configurado. Si ya existe una foto de perfil, será reemplazada. Requiere autenticación.
     * @summary Subir o actualizar la foto de perfil del usuario autenticado
     * @param {File} file El archivo de imagen a subir como foto de perfil.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsuariosApi
     */
    public uploadProfilePicture(file: File, options?: RawAxiosRequestConfig) {
        return UsuariosApiFp(this.configuration).uploadProfilePicture(file, options).then((request) => request(this.axios, this.basePath));
    }
}



